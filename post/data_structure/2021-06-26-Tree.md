---
title:  "AVL과 RB비교"
excerpt: "AVL과 RB비교"

categories:
 data_structure
tags:
 [data_structure, algorithm, tree, AVL_tree, red-black_tree]

toc: true
toc_sticky: true
date: 2021-06-26
---

# AVL 트리와 Red-Black 트리 비교

알다시피 트리의 높이는 곧 트리의 탐색시간을 결정한다. 이미 어떤 규칙에 의해 자식들로 나뉘는 트리에서 원하는 노드의 탐색 시간은 곧 일반적인 삽입과 삭제 시간 또한 결정한다. 따라서 트리가 어느 정도 편향되어 있는지, 자식 노드는 몇 개로 어떻게 구성되는지 같은 요소들은 트리의 전체적인 성능을 크게 좌우한다. 

자료구조의 시간적 복잡도를 고려하는 과정에서 최악의 경우를 고려하지 않을 수 없다. 가장 안 좋은 트리는 모든 노드가 형제를 갖지 않고 연결된 경우일 것이다. 극단적으로 편향된 이런 트리는 연결리스트와 거의 다를바 없다. 성능 또한 마찬가지일 것이다. 

다수의 데이터를 저장하기 위해 만들어진 자료구조인 만큼 이런 최악의 경우뿐만 아니라 '어느 정도 나쁜' 경우도 고려를 해야한다. 이런 경우를 대처하기 위해 사용하는 이진 트리의 종류가 바로 AVL 트리와 Red-Black 트리다. 

이 글에서는 두 트리의 자세한 구성 방법은 다루지 않겠다. 각 트리의 자세한 내용은 다음 문서들을 참고하기 바란다. 

[위키 백과 AVL 트리 항목](https://ko.wikipedia.org/wiki/AVL_%ED%8A%B8%EB%A6%AC)

[영문 위키 백과 Red-Black 트리 항목](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)

## 트리의 성능 측정

두 트리를 비교하기 위한 방법은 무엇이 있을까? 데이터 관리의 측면에서 데이터 또는 데이터가 있어야 할 곳에 얼마나 빠르게 접근할 수 있느냐가 자료구조의 성능을 결정할 것이다. 이진 트리에서 노드에 접근하는 속도는 어떻게 결정되는가? 탐색하려는 노드가 어떤 높이(또는 깊이)에 위치해 있는지가 곧 그 노드를 탐색하는데 걸리는 시간을 결정한다. 이 시간을 트리 전체 노드에 일반화 시킬 수 있을까? 완전 이진 트리에서는 (절반 + 1) 개의 노드가 리프에 위치한다. 따라서 가장 큰 높이를 가진 리프의 높이가 곧 해당 트리에서 탐색하는 데 필요한 최악의 복잡도를 결정함과 동시에 이것을 다른 노드들에 일반화 시켜도 큰 무리가 없다고 하겠다.

대단히 극단적으로 편향된 트리라면 리프의 높이가 다른 노드들의 복잡도를 대변할 수는 없지만 그런 트리는 이미 다른 노드들 조차 대단히 큰 높이를 갖고 있기 때문에 여기에서 고려하지 않는다. 

결론적으로 트리의 성능(시간적 복잡도)은 트리의 높이, 즉 가장 큰 높이를 가진 리프 노드의 높이가 결정한다. 반대로 말하자면 같은 높이일 때 더 많은 노드를 가지고 있을 수록 트리의 성능이 좋다. 다음과 같이 표현할 수 있을 것이다. 

$$SearchTime(T_1(h, n)) < SearchTime(T_2(h+i, n))$$

$$SearchTime(T_3(h, n)) == SearchTime(T_4(h, n+j))$$

트리 $$T_1$$의 경우 $$T_2$$와 같은 수의 노드를 갖고 있지만 더 작은 높이를 갖기 때문에 탐색시간이 빠르다. 이는 당연하다. 

트리 $$T_3$$은 $$T_4$$와 같은 높이를 갖고 있지만 더 적은 노드를 갖고 있다. 탐색시간은 둘이 같은데, 탐색 시간은 노드의 개수와는 독립적이고 높이와 비례하기 때문이다. 그러나 트리 $$T_4$$는 $$T_3$$보다 더 효율적이다. 같은 탐색시간으로 더 많은 노드를 탐색할 수 있기 때문이다. 따라서 우리는 다음과 같은 명제를 얻을 수 있다. 

- n이 같을 때, h가 작으면 빠른 트리다. 
- h가 같을 때, n이 크면 효율적인 트리다. 

이것들은 뒤에 두 트리를 비교하는 도구로 사용될 것이다. 

## AVL 트리 성능 측정

먼저 AVL트리의 성능을 측정해보자. AVL트리는 루트의 두 서브트리가 서로 2이상의 높이 차를 갖지 않도록 한다. 다시 말해 두 서브트리는 커봐야 1의 높이 차를 갖는다. 

위에서 보였다시피 트리의 성능을 측정하려면 극단적인 상황을 설정할 필요가 있다. 가장 편향된 AVL 트리를 구성한다. 아무리 편향된 AVL 트리라고 해도 두 서브트리는 1의 높이차를 가질 수 밖에 없다. $$N(h)$$가 높이 h의 편향된 AVL 트리가 갖는 노드 개수일 때, 3의 높이를 갖는 편향된 AVL 트리는 다음과 같은 노드 수를 가질 것이다. 

$$N(3) = N(2) + N(1) + 1$$

두 서브트리는 2와 1의 높이를 갖고 최대 높이 차이인 1을 보인다. 두 서브트리의 노드 개수와 루트 노드 1을 더하면 편향된 AVL 트리의 전체 노드 개수를 구할 수 있다. 위 식은 재귀적으로 적용되는데, 

$$N(2) = N(1) + N(0) + 1$$

$$N(1) = 1$$

$$N(0) = 0$$

위 식들을 일반화 해보면 다음과 같다. 

$$N(h) = N(h-1) + N(h-2) + 1, N(1) = 1, N(0) = 0$$

파이썬으로 재귀함수를 구현하여 명령행 인자로 높이를 받아 편향된 AVL 트리의 전체 노드 개수를 출력하는 코드

