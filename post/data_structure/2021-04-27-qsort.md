---
title:  "qsort analysis"
excerpt: ""

categories:
  - data structure
tags:
  - [data structure, algorithm, qsort, C, stdlib]

toc: true
toc_sticky: true
 
date: 2021-04-27
---

# qsort 함수 분석

정렬 알고리즘을 살펴보다보면 C언어에서 라이브러리에 퀵 정렬 함수가 있다는 것을 알게 된다. 이번에 정렬 알고리즘을 배우면서 qsort 함수를 실행하고 내가 직접 구현한 퀵 정렬과 그 실행시간을 비교할 기회가 있었다. 

가장 간단한 퀵 정렬 알고리즘은 최악의 경우 $$O(n^2)$$ 의 시간 복잡도를 갖는다. 정렬되지 않은 배열을 정렬할 때 $$log_{2}n$$의 재귀 단계를 가지지만, 피벗을 기준으로 파티션이 극단적으로 나뉠 때는 $$n^2$$의 단계를 갖는다. 

많이 쓰이는 힙 정렬은 비록 퀵 정렬보다 살짝 느리지만 이런 최악의 경우를 갖지 않고 항상 안정적인 시간 복잡도를 갖는다는 장점이 있다. 

이번 프로젝트에서 확인했던 일반적인 퀵 정렬 알고리즘의 실행시간은 다음과 같다. 데이터 개수는 5만개로 하였다.

* 정렬되지 않은 배열(일반적인 경우)

| 시행 | 시간 | 
|-|-|
|1|0.018301|
|2|0.024061|
|3|0.023780|
|4|0.021898|
|5|0.021349|

* 정렬된 배열(최악의 경우)

| 시행 | 시간 | 
|-|-|
|1|6.159308|
|2|6.295298|
|3|6.714806|
|4|6.275795|
|5|8.014508|

표에서 보다시피 입력으로 이미 정렬된 배열이 들어왔을때 퀵 정렬은 일반적인 경우에 비해 말도 안되는 성능 하락을 보인다. 퀵 정렬은 필연적으로 이런 최악의 경우를 피하기 위해 알고리즘을 적절히 편집할 필요가 있다. 

C언어 라이브러리 stdlib에 있는 qsort는 놀랍게도 이런 정렬된 배열을 입력으로 주었을 때도 수행시간이 증가하지 않았을 뿐만 아니라, 오히려 줄어들기까지 했다. 

* 정렬되지 않은 배열을 qsort에 넣었을 때

| 시행 | 시간 | 
|-|-|
|1|0.002869|
|2|0.002074|
|3|0.002466|
|4|0.002613|
|5|0.002080|

정렬되지 않은 일반적인 경우에서의 수행시간보다 열 배는 적은 시간을 사용했다. 

어리지만 그래도 코드를 쓰는 사람으로서 이를 능가하지는 못할 망정 따라잡고 싶은 마음이 들었다. 생각해보면 이미 정렬된 데이터를 다시 정렬하고자 할 때 수행시간이 늘어나는 것 자체가 직관적으로 이해되지 않는다. 이미 정렬되어 있다면 데이터 요소의 비교는 어쩔 수 없다고 해도 그 이동은 확연히 줄어들 것이라고 여기기 마련이다. 그렇다면 퀵 정렬에서 성능을 향상시킬 수 있는 방법이 어떤 것이 있을까? 퀵 정렬에서 피벗으로 범위의 중간값을 선택하거나, 배열을 무작위로 섞은 뒤 정렬하는 방법도 있을 것이다. 또한 스택 오버플로우의 위험을 갖는 재귀호출이 아닌 스택을 사용하는 방법도 있다. 이 세가지 방법을 모두 구현해보았다. 

먼저 입력받은 배열을 뒤섞고 정렬하는 퀵 정렬의 수행시간을 보았다. 

| 시행 | 시간 | 
|-|-|
|1|0.030819|
|2|0.027320|
|3|0.030205|
|4|0.027480|
|5|0.029770|

의에서 보였던 최악의 경우는 벗어났지만 수행시간이 늘어났다. 데이터의 셔플에서 수행시간을 까먹은 것으로 보인다. 최종적인 시간 복잡도는 $$O(nlog_{2}n)$$에서 벗어나지 않지만, $$O(n)$$을 갖는 

스택을 사용하는 퀵 정렬을 구현하고 피벗을 범위의 중간 값으로 선택하는 함수의 수행시간은 다음과 같다. 

* 스택 + 중간 요소가 피벗

| 시행 | 시간 | 
|-|-|
|1|0.002869|
|2|0.002074|
|3|0.002466|
|4|0.002613|
|5|0.002080|