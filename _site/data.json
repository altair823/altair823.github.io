[{"permalink":"//","layout":"default","title":"altair823","content":"# altair823\n\n그냥 이것저것 올리는 블로그\n\n## 소개\n\n### 김태현\n\n춘천고등학교 인문계열 졸업\n\n중앙대학교 심리학과 재학중\n\n중앙대학교 컴퓨터 공학 복수전공 이수중\n\n## Blog theme\n\n[jekyll-rtd-theme](https://github.com/rundocs/jekyll-rtd-theme)\n\n## The license\n\nThe theme is available as open source under the terms of the MIT License\n","dir":"/","name":"README.md","path":"README.md","url":"/"},{"title":"Word Finder 개발기 1","excerpt":"Word Finder 개발기 1","categories":"Python","tags":["Python","word_finder","toy_project"],"toc":true,"toc_sticky":true,"date":"2021-06-30","layout":"default","content":"<h1 id=\"word-finder-개발기-1\">Word Finder 개발기 1</h1>\n\n<p>어느 날 엄마가 일하는 모습을 보게되었다. 국어 학원 선생님이라 책에 나오는 어려운 단어를 아이들을 위해 검색하고 계셨다. 엄마는 그 많은 단어를 일일이 검색창에 치셔야 했다. 그것도 네이버 사전, 위키백과, 나무위키, 네이버 지식백과… 너무나 많은 검색을 하는 것이 보였다. 여기서 생각이 들었다.</p>\n\n<p>만약 저 많은 사이트에 검색하는 과정을 자동화하여 한 번의 검색으로 여러 사이트의 결과를 얻을 수 있으면 더 편해지지 않을까?</p>\n\n<p>그런 생각에 시작한 프로젝트가 바로 ‘Word Finder’이다. 가장 에센셜한 목표는 바로 검색 자동화와 그 결과를 한 화면에 모두 띄워주는 것이다. 결과론적으로 말하자면, 어느 정도 구조를 잡았다고 생각할 때 비로소 이 개발기를 시작하니 지금은 0.4.1 버전까지 나온 상태이다. 엄마도 이 프로그램을 유용하게 쓰시면서 수업준비를 하신다. 내 역량이 부족해 GUI 부분은 형편없기 그지 없지만 일단 그 외에는 나름 돌아간다고 생각한다.</p>\n\n<h2 id=\"가장-중요한-것\">가장 중요한 것</h2>\n\n<p>모든 프로젝트는 방향성이 가장 중요하다고 생각한다. 방향성은 프로젝트 자체의 퀄리티와 직접적으로 연관되어 있을 뿐만 아니라 프로젝트가 발전해 나가는 원동력이 되기 때문이다. 내가 지금 무엇을 위해 일을 하고 있는지 잊는다면 자연스레 능률도 떨어질 뿐만 아니라 쓸데없는 보여주기식 기능들이 추가되고 유지보수가 더 어려워질 뿐이다. 그래서 제일 먼저 프로그램의 목표부터 설정했다.</p>\n\n<ol>\n <li>단어 검색</li>\n</ol>\n\n<p>가장 중요한 기능이다. 단어의 입력과 결과의 출력이 어디로 나오던 그것은 세부사항일 뿐이다. 프로그램이 검색을 하지 못하면 당연하게도 단어 검색용으로 사용할 수 없다.</p>\n\n<ol>\n <li>여러 검색 결과를 한 화면에 모두 보여주기</li>\n</ol>\n\n<p>그저 한 페이지만 보여줄 수 있다면 네이버\u0010에 들어가서 검색하는 것과 다를 바 없을 뿐 아니라 오히려 이 프로그램을 쓸 이유가 없다. 여러 사전 사이트들에서 검색한 결과를 한 눈에 볼 수 있다는 것이 이 프로그램의 존재 이유이다.</p>\n\n<p>프로그램의 설계에 있어서 처음부터 완벽한 그림을 그리는 것은 불가능할 뿐만 아니라 악영향을 끼치지만 적어도 가장 중요한 기능에 있어서는 제일 먼저 중심에 놓고 시작하고 싶었다. 그래서 네이버 사전과 위키백과 각각에서 단어를 검색해 받은 HTML 코드 중 필요하다고 생각되는 부분만 문자열로 반환하는 클래스 두 개를 만들었다.</p>\n\n<p><a href=\"http://www.yes24.com/Product/Goods/77283734\">로버트 마틴의 클린 아키텍쳐</a>에 따르면 1번 기능을 구현한 모듈들은 프로젝트의 가장 안쪽에 위치해야 한다. 왜냐하면 일종의 정책이기 때문이다. 이것들은 입출력과 상관 없이 작동해야 하며 입출력의 존재조차 몰라야한다.</p>\n\n<p>2번을 구현하는데 있어서 가장 큰 부분을 차지하는 것은 GUI이다. 그리고 입출력과 가장 가까운 것도 GUI 이기 때문에 2번을 구현하는 모듈은 가장 바깥쪽에 위치해야 한다. GUI는 굉장히 변화하기 쉽고 또 그럴 것이기 때문에 1번과 같은 기능들에 영향이 가지 않도록 격리할 필요가 있다.</p>\n\n<p>GUI 프로그래밍이 이번이 두 번째고 아직 제대로 된 개념조차 못 잡은 상태였기 때문에 이 부분에 있어서 많은 어려움이 있었다. GUI를 바깥으로 빼내는 작업부터 GUI 자체를 구현하는 일까지 솔직히 깔끔하게 한 것이 더 적다고 생각한다.</p>\n\n<h2 id=\"그래도-중요한-것\">그래도 중요한 것</h2>\n\n<p>이 프로젝트는 엄마를 위한 것이기도 하지만 내 공부를 위한 것이기도 하다. 예전부터 의미있는 일을 하는 프로그램을 만들고 싶었다. 구구단이나 계산기, 기껏해야 왜 있는지도 모를 데이터들을 빠르게 정렬하는 프로그램들을 만들었다. 물론 그 과정이 굉장히 중요하고 의미있으며 나를 성장시켰다는 것에 전적으로 동의한다. 그래도 내게 무언가 도움이 되는 ‘자비스’ 같은 프로그램들을 꿈꾸기 마련 아닌가?</p>\n\n<p>내가 말하고 싶은 것은 내가 공부하며 알아가는 만큼 이 프로젝트도 변한다는 것이다. 현재는 두 개 밖에 없는 결과 창이 나중에 네 개가 될 것이고, 더 많은 기능들이 추가될 수 있다. 동시에 이 프로그램은 실 사용자가 존재하고(단 한명 뿐이지만 충분히 의미있다), 사용자에게 이 변화가 적용될 수 있어야 한다. 다시 말해, 업데이트 기능이 있어야 한다.</p>\n\n<p>업데이트는 수정된 프로그램을 사용자가 다운받아 설치하는 과정을 자동화시킨 것이라고 생각한다. 귀찮게 깃헙 사이트에 들어가서 릴리즈 버전을 다운 받는 수고를 들이지 않고 프로그램 내에서 쉽게 업데이트할 수 있도록 구현하고자 하였다.</p>\n\n<h2 id=\"모델\">모델</h2>\n\n<p>사람이 살면서 어느 한 순간은 누군가를 닮고 싶기 마련이다. 나도 내 프로젝트가 닮았으면 하는 프로그램이 있었다. 개발자께서 원하지 않아 무엇인지는 밝히지 않지만, 1인 개발에 소스코드를 모두 깃헙에 올려두지 않은 프로그램이었다. 파이썬으로 구현되어있으며 PyQt5를 사용한 GUI라는 정보 외에는 딱히 알 수 있는 것이 없었다. 직접 개발자 본인에게 문의해 소스코드를 받을 수 있었다. 커밋관리나 문서를 정리하기 귀찮아서 올려놓지 않았다고 하셨다.</p>\n\n<p>소스를 받아본 나는 깜짝 놀랐다. 아무리 단 한 사람의 메인테이너 밖에 없다고 하지만 단 한줄의 주석조차 볼 수 없었다. 코어 모듈들은 단 한 개의 패키지에도 들어가있지 않았고 그 의존성도 파악하기 너무나 어려웠다. 한 모듈이 여러 곳에 쓰이면서도 어떤 수준을 갖고 존재하는지 알 수 없었다. 플래그 변수명은 ‘res’, ‘d’, ‘r’ 등이어서 도대체 무슨 값을 나타내는 플래그인지 알아내려면 함수 원형을 찾아가야 했다. 어떤 파일은 IDE가 차마 분석할 수 없을 만큼 길면서도 그 안에 서로 다른 일들을 하는 클래스들이 여럿 들어가 있었다. 대단히 분석하기 어려웠다.</p>\n\n<p>몇 가지 건진 것들이 있는데 나중에 풀어보도록 하겠다.</p>\n\n<h2 id=\"구조\">구조</h2>\n\n<p>하여간 나는 더 친절하고 유지보수하기 쉬운 코드를 쓰고 싶었다. 그게 나에게 더 편한 길임과 동시에 옳은 길이기 때문이다. 간단한 프로그램이지만 모듈들을 최대한 기능에 따라 분리하고 입출력에 더 가까운 모듈이 그렇지 않은 모듈을 참조하고 반대의 경우는 발생하지 않도록 하였다. 이에 대한 자세한 내용은 나중에 다루어볼 예정이다.</p>\n\n<h2 id=\"마무리\">마무리</h2>\n\n<p>비록 많이 부족한 실력이지만 그동안 배운 것들과 지금 배우고 있는 것들을 직접 사용해보고 구체화하는 과정에서 공고히 할 수 있었다. 생전 관심 없었던 PyQt5도 외국 원서까지 구매해 봐가면서 익혀야 했고 반응성 개선을 위해 멀티스레딩도 머리 싸매며 공부했다. 내가 워낙 모자라서 그런지 몰라도 정말 많이 배울 수 있었던 프로젝트였다.</p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/Python/","name":"2021-06-30-Project_Word_Finder_1.md","path":"post/Python/2021-06-30-Project_Word_Finder_1.md","url":"/post/Python/2021-06-30-Project_Word_Finder_1.html"},{"title":"Word Finder 개발기 2","excerpt":"Word Finder 개발기 2","categories":"Python","tags":["Python","word_finder","toy_project"],"toc":true,"toc_sticky":true,"date":"2021-07-04","layout":"default","content":"<h1 id=\"word-finder-개발기-2---업데이트\">Word Finder 개발기 2 - 업데이트</h1>\n\n<p>내가 모델로 했던 프로그램의 소스코드에서 얻은 것이 있다면 업데이트 로직이라고 하겠다. 다음은 대략적인 순서다.</p>\n\n<ol>\n <li>서버에서 업데이트된 프로그램의 압축파일을 임시 폴더에 받아온다.</li>\n <li>임시폴더 안의 내용을 모두 압축 해제 한다.</li>\n <li>현재 실행중인 프로그램을 임시폴더로 넣고 이름을 바꾼다.</li>\n <li>임시폴더에 있는 새로운 프로그램을 밖으로 꺼내고 실행시킨다.</li>\n</ol>\n\n<p>3, 4번 과정에서 원래 켜져 있던 프로그램이 닫히고 새로운 프로그램이 열리게 된다. 많은 경우 웹 서버에 업데이트 파일을 올리고 거기서 내려받는 것을 볼 수 있었다. 하지만 나 같은 경우 라즈베리파이로 만든 NAS에 저장하고 외부 포트를 열어 익명 접속을 통해 파일을 내려받도록 하였다.</p>\n\n<p>조금 더 구체적인 순서를 보이자면 다음과 같다.</p>\n\n<ol>\n <li>\n <p>사용자가 업데이트 메뉴를 클릭한다.</p>\n </li>\n <li>\n <p>먼저 FTP 서버에 접속해 현재 프로그램과 서버의 올라온 버전을 비교한다.</p>\n\n <p>2-1. 만약 현재 버전이 더 높거나 같다면 업데이트할 필요가 없다는 메세지를 띄우고 돌아간다.</p>\n </li>\n <li>\n <p>서버의 버전이 더 높다면 updater 스레드를 생성한다.</p>\n </li>\n <li>\n <p>updater 스레드는 서버에서 파일을 내려받는다.</p>\n\n <p>4-1. 먼저 서버에 로그인하고 타겟 파일의 용량을 스레드 신호로 내보낸다.</p>\n\n <p>4-2. 타겟 파일을 내려받는다.</p>\n\n <p>4-3. 내려받은 파일의 압축을 푼다.</p>\n\n <p>4-4. 현재 돌아가는 exe파일을 임시 폴더에 이름을 바꾸어 넣고, 임시 폴더에 받은 타겟 exe파일을 현재 경로로 꺼낸다.</p>\n\n <p>4-5. 꺼낸 새 파일을 실행시킨다.</p>\n </li>\n <li>\n <p>updater 스레드가 타겟 파일의 용량을 신호로 보내면 update_checker 라는 새 스레드를 만든다.</p>\n\n <p>5-1. 이 스레드는 현재 임시 폴더에 존재하는 파일의 용량과 타겟 파일의 용량(목표 용량)을 계속 비교한다.</p>\n\n <p>5-2. 비교한 값을 백분율로 환산하여 일정 간격마다 신호로 보낸다.</p>\n </li>\n <li>\n <p>메인 스레드는 받은 신호, 즉 progress 값을 창의 진행 바로 표시한다.</p>\n </li>\n <li>\n <p>모든 절차가 끝나면 현재 창이 닫히고 다운로드한 새 프로그램이 실행된다.</p>\n </li>\n</ol>\n\n<p>먼저 다음은 업데이트 메뉴를 클릭했을 때 나타나는 창 클래스이다.</p>\n\n<pre><code class=\"language-{.py}\">class Updater_GUI(QDialog, updater_gui):\n    def __init__(self, parent, filename):\n        super(Updater_GUI, self).__init__(parent)\n        self.setupUi(self)\n        self.setWindowTitle('Update')\n        self.show()\n        self.filename = filename\n        self.total_size = 0\n\n        # 업데이트하는 worker를 생성한다.\n        self.threadpool = QThreadPool()\n        self.update_worker = updater.Updater(self.filename)\n        self.update_worker.set_sever(WORDFINDER_FTP_SERVER)\n        self.update_worker.set_dir(TEMP_UPDATE_DIR)\n        self.threadpool.start(self.update_worker)\n\n        # 업데이트 worker가 파일 전체 용량을 가르쳐주면 그때부터 진행상황을 체크한다.\n        self.update_worker.signal.total_size.connect(self.check_progress)\n        self.update_worker.signal.finished.connect(self.close)\n\n    def check_progress(self, size):\n        self.total_size = size\n        if self.total_size == 0:\n            return\n\n        # 업데이트 진행상황을 체크하는 worker 스레드 클래스.\n        class _update_checker(QRunnable):\n            def __init__(self, filename, total_size):\n                super(_update_checker, self).__init__()\n                self.signals = check_signal()\n                self.filename = filename\n                self.total_size = total_size\n\n            @pyqtSlot()\n            def run(self):\n                current_size = 0\n                total = self.total_size\n                sleep(3)\n                # 업데이트 진행상황을 일정한 간격으로 체크한다.\n                while (current_size &lt;= total):\n                    if os.path.isfile(os.path.join(TEMP_UPDATE_DIR, self.filename + '.zip')):\n                        current_size = os.path.getsize(os.path.join(TEMP_UPDATE_DIR, self.filename + '.zip'))\n                    else:\n                        return\n                    self.signals.progress.emit((int(current_size) / total) * 100)\n                    sleep(0.01)\n\n        self.progress_checker = _update_checker(self.filename, self.total_size)\n        self.threadpool.start(self.progress_checker)\n        self.progress_checker.signals.progress.connect(self.progress_bar.setValue)\n</code></pre>  \n\n<p><a href=\"https://github.com/altair823/WordFinder/blob/master/gui/update_window_gui.py\">전체 코드</a>는 깃허브에서 볼 수 있다.</p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/Python/","name":"2021-07-05-Project_Word_Finder_2.md","path":"post/Python/2021-07-05-Project_Word_Finder_2.md","url":"/post/Python/2021-07-05-Project_Word_Finder_2.html"},{"title":"Word Finder 개발기 3","excerpt":"Word Finder 개발기 3","categories":"Python","tags":["Python","word_finder","toy_project"],"toc":true,"toc_sticky":true,"date":"2021-06-30","layout":"default","content":"<h1 id=\"word-finder-개발기-3\">Word Finder 개발기 3</h1>\n\n<p>나 스스로가 모자라고 더 많이 배워야 하는 상황에서 한 번 쓴 코드가 바뀌지 않을 것이라고 생각하지 않는다. 오히려 내가 배우는 만큼 훨씬 더 많이 바뀔 것이다. 어느 프로젝트나 마찬가지지만, 이런 내 상황에서는 유지보수성에 높은 우선순위를 둘 수 밖에 없었다.</p>\n\n<h2 id=\"유지보수\">유지보수</h2>\n\n<p>유지보수란 무엇인가? 프로그램 내부의 오류를 쉽게 잡을 수 있고, 외부의 변화에 유연하게 대응 가능하며, 다른 사람이 알아보기도 쉬운 것이라고 생각한다. 그리고 개인적으로 확장성도 그 안에 포함되는 것 같다. 단지 변수 이름을 알맞게 짓거나 함수를 잘개 쪼개는 것만으로는 유지보수성을 챙기기 어렵다. 무언가 구조적인 방법이 필요했다.</p>\n\n<h2 id=\"클린-아키텍쳐\">클린 아키텍쳐</h2>\n\n<p><a href=\"http://www.yes24.com/Product/Goods/77283734\">로버트 마틴이 클린 아키텍쳐</a>에서 이야기한 아키텍쳐를 최대한 적용하려 노력했다. 간단한 프로그램이지만 모듈들을 최대한 기능에 따라 분리하고 입출력에 더 가까운 모듈이 그렇지 않은 모듈을 참조하고 반대의 경우는 발생하지 않도록 하였다.</p>\n\n<p>예를 들어 검색 기능을 살펴보자. 사용자가 느끼는 과정은 다음과 같다.</p>\n\n<ol>\n <li>검색창에 단어를 친다.</li>\n <li>검색 버튼을 누르거나 엔터키를 누른다.</li>\n <li>창에 단어의 뜻이 나타난다.</li>\n</ol>\n\n<p>이 프로그램에서 진행되는 일련의 과정은 다음과 같다.</p>\n\n<ol>\n <li>검색 버튼이나 엔터키가 눌리면 검색창의 단어를 target으로 저장한다.</li>\n <li>target를 매개변수로 WordInput를 생성한다.</li>\n <li>WordInput은 두 스크래퍼 중 하나를 만들어 반환하는데, 예를 들어,\n <ul>\n <li>get_naver_finder() - 네이버 사전을 긁어오는 NaverFinder를 target을 매개변수로 생성해 반환한다.</li>\n <li>get_wiki_finder() - 위키백과를 긁어오는 WikipediaFinder를 target을 배개변수로 생성해 반환한다.</li>\n </ul>\n </li>\n <li>이후 각 Finder에서 찾은 페이지html을 Presenter를 통해 원하는 부분만 문자열(result)로 반환한다.</li>\n <li>해당 문자열(result)을 GUI 창에 띄운다.</li>\n</ol>\n\n<p>“검색창 -&gt; 페이지 탐색과 html반환 -&gt; html에서 원하는 부분만 GUI에 출력”으로 구현할 수 있는 간단한 과정을, 이를 분리하고 그 중간에 WordInput이나 Presenter를 도입한 이유는 무엇일까?</p>\n\n<p>만약 NaverFinder가 검색창 입력 target을 직접 받아 처리하고 원하는 단어의 뜻만 문자열로 출력한다고 해보자. 구현은 쉬울 것이다. target을 바로 NaverFinder에게 넘기고 .find()의 반환 값 result를 GUI에 띄우면 된다. target과 result를 원하는 형태로 가공하는 것(예를 들어 올바른 입력값인지 검증하거나, 출력값의 공백문자를 없앤다거나)은 NaverFinder 안에 포함될 것이다(자잘한 함수로 나눌 수는 있겠지만 어찌되었건 같은 컴포넌트로 묶인다고 해보자).</p>\n\n<p>만약 사용자가 요구하기를, 검색 창에 단어를 입력하는 방식이 아니라 파일에 일련의 단어들을 주욱 나열해 놓고 그것 전체를 검색해주기 바란다고 하자. NaverFinder 컴포넌트를 계속 사용하기 바란다면 프로그램은 입력이 검색창 문자열인지, 단어 파일인지, 파일이라면 올바른 파일인지 검증해야 한다. 그리고 파일의 내용을 원하는 형태로 다시 가공해야하고…</p>\n\n<p>이번에는 사용자가 GUI 화면을 추가해달라 요청했다고 하자. 단순 문자열 옆에 웹 페이지 자체를 보여주기 바란다. 이제 NaverFinder는 html의 일부를 문자열로 반환하는 것뿐만 아니라 html 전체를 반환해야한다. NaverFinder는 이제 둘을 나누어 반환해야 한다. .get_html()과 .get_str()이라고 하자. 원래는 .find()였지만 이제 함수명이 달라졌다. 따라서 이를 사용하는 모든 컴포넌트를 수정해야 한다. 컴파일 언어라면 재컴파일 해야할 것이다.</p>\n\n<p>너무나 많은 노력이 드는 작업이다. 이에 대해 클린 아키텍쳐는 이를 분리해 경계를 나눌 것을 조언한다. NaverFinder는 일종의 정책이다. 프로그램의 가장 본질적인 기능이라는 뜻이다. 프로그램은 사전에서 단어를 검색해야하고, NaverFinder는 그 역할을 하는 가장 중심의 컴포넌트다. 코드의 추가에는 열려있고 수정에는 닫혀있어야하는 유스케이스다(use case).</p>\n\n<p>만약 NaverFinder의 입력과 출력 양쪽에 대응하는 두 인터페이스가 있다면 어떨까? 입력장치가 바뀌었을 때 그 입력장치에서 주어진 입력을 NaverFinder가 원하는 형식으로 바꾸어주는 적절한 인터페이스와, 출력장치가 바뀌었을 때 NaverFinder의 출력을 적절하게 바꾸어 출력 장치로 전달해주는 인터페이스를 올바르게 구현하고 선택할 수 있다면? NaverFinder는 전혀 수정하지 않고 계속 사용할 수 있을 것이다.</p>\n\n<p>WordInput은 입력 인터페이스의 역할을 한다. 비록 지금은 NaverFinder에게 필요한 같은 문자열을 입력받지만, 입력장치는 바뀌기 굉장히 쉽기 때문에 완충역할을 해준다. NaverFinder는 html 전체를 반환한다. 현재 GUI 출력에 필요한 것은 뜻 문자열 뿐이므로, Presenter가 html을 원하는 문자열로 바꾼다. 따라서 다음과 같은 데이터 흐름을 갖는다.</p>\n\n<p>검색창 입력 -&gt; WordInput -&gt; NaverFinder -&gt; Presenter -&gt; GUI 출력</p>\n\n<h2 id=\"마무리\">마무리</h2>\n\n<p>아직 경험이 많이 부족해 책에 대한 깊은 이해는 하지 못했다고 생각한다. 그래도 여러 프로젝트를 하며 머릿속을 맴돌던 소프트웨어 아키텍쳐에 대한 개념을 확실히 잡게 해준 책이었다. 이 프로젝트를 진행하면서 제대로된 프로그램 구조를 생각하고 구현할 수 있게 되었다.</p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/Python/","name":"2021-07-05-Project_Word_Finder_3.md","path":"post/Python/2021-07-05-Project_Word_Finder_3.md","url":"/post/Python/2021-07-05-Project_Word_Finder_3.html"},{"layout":"default","title":"미로 생성 알고리즘","content":"<h1 id=\"미로-생성-알고리즘\">미로 생성 알고리즘</h1>\n\n<p>학기 중에 미로 탐색 과제를 했었다. 주어진 미로의 최단경로와 그 개수를 탐색하는 DFS 알고리즘을 만들었다. 스택을 사용하여 길이 막힐 때마다 갈림길로 돌아오고, 도착점에 이르렀을 경우 다시 이전 갈림길로 돌아가 다른 길이 존재하는지, 존재한다면 이전의 경로보다 짧은지 탐색하는 알고리즘이었다. 더 이상 찾아볼 경로가 존재하지 않을 때 이 알고리즘은 종료된다.</p>\n\n<p>결과적으로 알고리즘은 잘 작동했다. 하지만 내가 만족스럽지 못했던 점은 알고리즘을 테스트할 수 있는 환경이 미리 주어진 미로 밖에 없었다는 점이다. 물론 미로를 약간 수정하여 입력할 수 있었지만 어디까지나 약간의 수정에 불과했고 더 큰 미로에서 얼마나 이 알고리즘이 잘 작동하는지 알고 싶었다. 그런 의미에서 완전히 무작위적인 미로를 만드는 방법을 알고 싶었다. 비록 그때는 시간에 쫒겨 구현하지 못했지만 이번 기회에 구현하게 되었다.</p>\n\n<h2 id=\"종류\">종류</h2>\n\n<p>미로 생성 알고리즘에는 여러가지가 있다. Recursive backtracking, Eller’s 알고리즘, 최소신장트리를 이용한 알고리즘, 이진트리 알고리즘 등. 각각의 특징을 간략하게 설명하자면 다음과 같다.</p>\n\n<ol>\n <li>Recursive backtracking: 구현이 간단하지만 재귀적 호출이 필요하다(물론 반복문으로 바꿀 수 있다).</li>\n <li>Eller’s 알고리즘: 구현이 복잡하고 이해하기 어렵지만, 무조건 선형시간에 미로를 생성하므로 가장 빠르다.</li>\n <li>최소신장트리를 사용한 알고리즘: 구현이 간단하지만 이해하기가 약간 어렵고 짧은 막다른 길을 자주 생성한다.</li>\n <li>이진트리 알고리즘: 경로에 편향이 존재하지만 구현이 간단하다.</li>\n</ol>\n\n<p>이번 프로젝트에서는 Eller의 알고리즘을 사용하여 미로를 생성하였다. 많은 수의 큰 미로를 생성하고 그 모두에 탐색 알고리즘을 돌려 성능을 알아보고 싶었기 때문에 빠르게 미로를 만드는 것이 중요하다고 생각했다.</p>\n\n<h3 id=\"ellers-algorithm\">Eller’s Algorithm</h3>\n\n<p>그렇다면 Eller의 알고리즘의 순서를 정리해보자.</p>\n\n<ol>\n <li>첫 행의 칸들을 모두 각각 다른 집합에 포함시킨다.</li>\n <li>인접한 칸들을 무작위로 연결한다. 이때 연결한 칸들은 같은 집합으로 묶는다.</li>\n <li>현재 행의 모든 집합들은 적어도 하나의 아래 칸을 연결한다. 이 역시 같은 집합으로 묶는다.</li>\n <li>다음 줄로 이동한다.</li>\n <li>집합에 포함되지 않은 칸들을 각각 새로운 집합에 포함시킨다.</li>\n <li>마지막 행이 아니라면 2부터 다시 반복한다.</li>\n <li>마지막 행이라면, 다른 집합에 속한 칸들을 모두 같은 집합으로 연결한다.</li>\n</ol>\n\n<p>기본적인 정의는 위와 같지만 분명히 이해하기 어렵고 각 단계가 미로 생성에서 의미하는 바가 명확히 드러나지 않는다. 먼저 가장 중요한 전제부터 다루어보자.</p>\n\n<h2 id=\"단계-분석\">단계 분석</h2>\n\n<p>모든 벽의 초기 상태는 닫힘 상태이어야 한다. 그리고 인접한 두 칸이 같은 집합으로 묶이는 순간, 두 칸 사이의 벽은 열리게 된다. 이 때 조심해야 할 것은 벽이 열리는 조건은 ‘두 칸이 같은 집합으로 묶이는 순간’이라는 것이다. 자세한 이유는 아래에 설명하겠다.</p>\n\n<ol>\n <li>만약 5x2 크기를 갖는 미로를 생성한다고 하자. 첫 행은 5칸으로 이루어져 있다. 1번 단계에 따라서 각 칸은 1번 집합, 2번 집합, 3번 집합, 4번 집합, 5번 집합에 포함된다. 같은 집합에 포함되는 인접한 칸은 존재하지 않으므로 열리는 벽도 없다.</li>\n <li>무작위적으로 인접한 칸과 같은 집합으로 묶는다. 묶이는 순간 둘 사이의 벽도 열리게 된다. 각기 다른 집합에 속하던 칸들은 이제 2 2 3 4 4 이런 식으로 일부가 서로 같은 집합에 속하게 된다.</li>\n <li>모든 집합은 적어도 하나의 아래 칸을 같은 집합으로 묶는다. 위의 예시에서 진행한다면 다음 행의 집합 상태는 아마 2 * 3 4 4 와 같은 상태일 것이다. * 으로 표시된 칸은 아직 집합에 할당하지 않은 칸이다.</li>\n <li>다음 줄로 이동한다. 여기가 Eller의 알고리즘이 높은 성능을 보이는 이유인데, 한번 그린 행을 다시는 쳐다보지 않고 아래로 내려가기 때문이다. 이제 2 * 3 4 4 가 현재 행의 집합 상태가 된다.</li>\n <li>현재 행에서 집합에 속하지 않은 칸, 즉 * 을 새로운 집합에 넣는다. 이미 없어진 집합인 1에 넣으면 2 1 3 4 4와 같다.</li>\n <li>마지막 행이 아니라면 다시 2부터 진행한다.</li>\n <li>편의상 2 1 3 4 4 가 마지막 행의 상태라고 가정해보자. 이대로 알고리즘이 끝난다면 1번 집합, 2번 집합, 3번 집합, 4번 집합은 서로 절대 만나지 않는 미로의 길이 될 것이다. 만약 중간에 만나는 길이 존재한다면 2번 단계에서 길이 열렸을 것이며, 같은 집합으로 묶였을 것이기 때문이다. 따라서 모든 길이 연결되도록 하기 위하여 다른 집합에 속한 칸들을 모두 이어준다.\n <ol>\n <li>첫 번째 칸(2)와 두 번째 칸(1)을 이어준다. 따라서 두 칸의 집합은 모두 2가 된다.</li>\n <li>세 번째 칸(3)도 집합이 다르니 이어준다. 따라서 세 번째 칸 또한 2번 집합에 들어간다.</li>\n <li>네 번째 칸(4)도 같은 집합으로 묶는다. 이때 주의해야 하는데, 칸을 같은 집합으로 묶는다는 의미는 단순히 그 칸을 자신의 집합에서 꺼내어 현재 집합에 넣는다는 것이 아니다. 그 칸의 집합과 현재 집합 전체를 합병한다는 의미이다. 이 과정에서 단지 붙어있는 두 칸 사이의 벽 하나만 열릴 뿐이다. 따라서 네 번째 칸이 2번 집합에 들어감과 동시에 다섯 번째 칸도 2번 집합에 들어간다.</li>\n <li>네 번째 칸과 다섯 번째 칸은 가운데 닫힌 벽이 존재한다. 3번 과정에서 보다시피 두 칸은 가로로 서로 합병한 칸이 아니라 위의 4번 집합에서 동시에 내려왔을 뿐이기 때문이다. 따라서 가운데 벽이 여전히 존재하고 다만 바로 윗 행 때문에 서로 이어져 있으므로 같은 집합에 속하는 것이다. 따라서 두 칸은 모두 2번 집합에 속하기 때문에 둘 사이의 벽을 허물지 않고 그대로 넘어간다.</li>\n </ol>\n </li>\n</ol>\n\n<p>이 모든 과정이 끝나면 결과적으로 모든 칸이 단 하나의 집합에 속하게 된다. 집합이 서로 달랐던 두 칸은 2번 과정에서 서로 합병되고, 마지막까지 달랐던 칸들은 7번 과정에서 같은 집합에 속하게 된다. 같은 집합에 속한 칸들은 반드시 서로 이어져 있다는 것을 생각하면, 이는 곧 모든 칸이 서로 이어져 있다는 뜻이다.</p>\n\n<p>여기에서 익숙함을 느낄 수 있는데, Eller의 알고리즘에서 ‘집합’이라는 개념은 곧 하나의 그래프를 뜻한다는 것을 알 수 있다. 서로 다른 집합을 합병하는 것은 서로 이어져 있지 않은 두 그래프를 연결하는 것과 같다. 두 그래프를 연결하는데 단 한개의 엣지면 충분하므로, 두 집합을 합병하는 것 역시 단 한개의 벽을 열기만 하면 된다.</p>\n\n<p>또한 미로 자체를 그래프로서 표현할 수 있는데, 이에 대해서는 <a href=\"\">ㅓ복햅고ㅝㅐㅎ보ㅜㄱ혀ㅐㅓ뷰ㅗㅜ</a>에 자세히 적었다.</p>\n\n<h2 id=\"복잡도-분석\">복잡도 분석</h2>\n\n<p>놀랍게도 이 알고리즘은 윗 행을 전혀 참고하지 않는다. 단지 현재 행을 조작하고 다음 행의 집합을 미리 정하는 것이 전부이다. 모든 과정은 한 행씩 내려가며 진행된다. 따라서 칸 수에 대한 선형의 시간적 복잡도를 갖는다.</p>\n\n<h2 id=\"구현\">구현</h2>\n\n<p>각 칸을 Set 컨테이너에 넣고 이에 대한 연산을 하는 것은 정의에 맞는 구현이지만, 각 사이클에서 이전 행의 정보를 필요로 하지 않는다는 것을 상기한다면 이는 분명 필요 이상의 오버헤드를 일으킨다. 한 행에 대응하는 1차원 정수형 배열 하나를 정의하고 특정 행에서 각 칸이 소속된 집합을 정수로 표현한다면 훨씬 가볍게 연산할 수 있을 것이다.</p>\n\n<p>그렇다면 집합 값은 몇까지 할당되는가? 한 행에서 각 칸에 할당할 수 있는 집합의 최대 개수는 곧 한 행에서 칸의 개수와 동일하다. 하지만 합병되어 없어진 집합 값을 추적하지 않는다면 새로 할당하는 집합 값은 충돌을 피하기 위해 앞에서 전혀 쓰이지 않았던 집합 값이 될 것이다. 조금 단순화해서 생각해본다면 할당되는 최대 집합 값은 미로 전체의 칸 수와 선형적으로 비례할 것이다. 작은 미로를 생성한다면 크게 의미 없겠지만 큰 미로를 생성한다면 더 이상 사용하지 않는 집합 값이 존재함에도 불구하고 오버플로우의 위험을 안고 있는 것이다.</p>\n\n<p>현재 사용 중인 집합 값을 Set 컨테이너에 저장하고 집합이 합병될 때마다 이를 갱신하도록 하였다. 집합을 할당할 때는 1부터 최대값까지 Set에 존재하지 않는 집합 값을 찾아 이를 할당하고 Set에 넣었다.</p>\n\n<p>필요한 것은 현재 행의 집합 값을 저장할 1차원 정수형 배열과 다음 행의 집합 값을 저장할 1차원 정수형 배열, 현재 사용 중인 집합 값을 저장할 집합이다. 이들을 사용하면 위에서 설명한 단계들을 구현하는데 큰 무리가 없을 것이다.</p>\n\n<h2 id=\"마치며\">마치며</h2>\n\n<p>무작위적인 미로를 빠르게 생성하는 Eller의 알고리즘을 살펴보았다. 이제 이를 바탕으로 다익스트라 알고리즘과 A*같은 여러 최단 경로 탐색 알고리즘을 테스트할 환경을 마련할 수 있었다.</p>\n\n<p>미로의 자료구조에 대한 자세한 내용은 <a href=\"\">ㄷㄹㅂㄷㄹㅂㄷㄹㅂㄷㄹ</a>에서 볼 수 있다.</p>\n\n<p>전제 소스 코드는 <a href=\"https://github.com/altair823/MazeMaker\">MazeMaker</a>에서 볼 수 있다.</p>\n\n<h2 id=\"참고\">참고</h2>\n\n<p><a href=\"http://weblog.jamisbuck.org/2011/2/7/maze-generation-algorithm-recap.html\">Maze Generation: Algorithm Recap</a></p>\n\n<p><a href=\"http://weblog.jamisbuck.org/2010/12/29/maze-generation-eller-s-algorithm\">Maze Generation: Eller’s Algorithm</a></p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/algorithm/","name":"2021-07-13-Eller's_algorithm.md","path":"post/algorithm/2021-07-13-Eller's_algorithm.md","url":"/post/algorithm/2021-07-13-Eller's_algorithm.html"},{"title":"qsort.c 분석","excerpt":"qsort.c 분석","categories":"data_structure","tags":["data_structure","algorithm","qsort","C","stdlib"],"toc":true,"Comments":true,"toc_sticky":true,"date":"2021-04-27","layout":"default","content":"<h1 id=\"qsort-함수-분석\">qsort 함수 분석</h1>\n\n<p>정렬 알고리즘을 살펴보다보면 C언어에서 라이브러리에 퀵 정렬 함수가 있다는 것을 알게 된다. 이번에 정렬 알고리즘을 배우면서 qsort 함수를 실행하고 내가 직접 구현한 퀵 정렬과 그 실행시간을 비교할 기회가 있었다.</p>\n\n<p>가장 간단한 퀵 정렬 알고리즘은 최악의 경우 \\(O(n^2)\\) 의 시간 복잡도를 갖는다. 정렬되지 않은 배열을 정렬할 때 \\(log_{2}n\\)의 재귀 단계를 가지지만, 피벗을 기준으로 파티션이 극단적으로 나뉠 때는 \\(n^2\\)의 단계를 갖는다.</p>\n\n<p>많이 쓰이는 힙 정렬은 비록 퀵 정렬보다 살짝 느리지만 이런 최악의 경우를 갖지 않고 항상 안정적인 시간 복잡도를 갖는다는 장점이 있다.</p>\n\n<p>이번 프로젝트에서 확인했던 일반적인 퀵 정렬 알고리즘의 실행시간은 다음과 같다. 데이터 개수는 5만개로 하였다.</p>\n\n<ul>\n <li>정렬되지 않은 배열(일반적인 경우)</li>\n</ul>\n\n<table>\n <thead>\n <tr>\n <th>시행</th>\n <th>시간</th>\n </tr>\n </thead>\n <tbody>\n <tr>\n <td>1</td>\n <td>0.018301</td>\n </tr>\n <tr>\n <td>2</td>\n <td>0.024061</td>\n </tr>\n <tr>\n <td>3</td>\n <td>0.023780</td>\n </tr>\n <tr>\n <td>4</td>\n <td>0.021898</td>\n </tr>\n <tr>\n <td>5</td>\n <td>0.021349</td>\n </tr>\n </tbody>\n</table>\n\n<ul>\n <li>정렬된 배열(최악의 경우)</li>\n</ul>\n\n<table>\n <thead>\n <tr>\n <th>시행</th>\n <th>시간</th>\n </tr>\n </thead>\n <tbody>\n <tr>\n <td>1</td>\n <td>6.159308</td>\n </tr>\n <tr>\n <td>2</td>\n <td>6.295298</td>\n </tr>\n <tr>\n <td>3</td>\n <td>6.714806</td>\n </tr>\n <tr>\n <td>4</td>\n <td>6.275795</td>\n </tr>\n <tr>\n <td>5</td>\n <td>8.014508</td>\n </tr>\n </tbody>\n</table>\n\n<p>표에서 보다시피 입력으로 이미 정렬된 배열이 들어왔을때 퀵 정렬은 일반적인 경우에 비해 말도 안되는 성능 하락을 보인다. 퀵 정렬은 필연적으로 이런 최악의 경우를 피하기 위해 알고리즘을 적절히 편집할 필요가 있다.</p>\n\n<p>C언어 라이브러리 stdlib에 있는 qsort는 놀랍게도 이런 정렬된 배열을 입력으로 주었을 때도 수행시간이 증가하지 않았을 뿐만 아니라, 오히려 줄어들기까지 했다.</p>\n\n<ul>\n <li>정렬되지 않은 배열을 qsort에 넣었을 때</li>\n</ul>\n\n<table>\n <thead>\n <tr>\n <th>시행</th>\n <th>시간</th>\n </tr>\n </thead>\n <tbody>\n <tr>\n <td>1</td>\n <td>0.002869</td>\n </tr>\n <tr>\n <td>2</td>\n <td>0.002074</td>\n </tr>\n <tr>\n <td>3</td>\n <td>0.002466</td>\n </tr>\n <tr>\n <td>4</td>\n <td>0.002613</td>\n </tr>\n <tr>\n <td>5</td>\n <td>0.002080</td>\n </tr>\n </tbody>\n</table>\n\n<p>정렬되지 않은 일반적인 경우에서의 수행시간보다 열 배는 적은 시간을 사용했다.</p>\n\n<p>어리지만 그래도 코드를 쓰는 사람으로서 이를 능가하지는 못할 망정 따라잡고 싶은 마음이 들었다. 생각해보면 이미 정렬된 데이터를 다시 정렬하고자 할 때 수행시간이 늘어나는 것 자체가 직관적으로 이해되지 않는다. 이미 정렬되어 있다면 데이터 요소의 비교는 어쩔 수 없다고 해도 그 이동은 확연히 줄어들 것이라고 여기기 마련이다. 그렇다면 퀵 정렬에서 성능을 향상시킬 수 있는 방법이 어떤 것이 있을까? 퀵 정렬에서 피벗으로 범위의 중간값을 선택하거나, 배열을 무작위로 섞은 뒤 정렬하는 방법도 있을 것이다. 또한 스택 오버플로우의 위험을 갖는 재귀호출이 아닌 스택을 사용하는 방법도 있다. 이 세가지 방법을 모두 구현해보았다.</p>\n\n<p>먼저 입력받은 배열을 뒤섞고 정렬하는 퀵 정렬의 수행시간을 보았다.</p>\n\n<table>\n <thead>\n <tr>\n <th>시행</th>\n <th>시간</th>\n </tr>\n </thead>\n <tbody>\n <tr>\n <td>1</td>\n <td>0.030819</td>\n </tr>\n <tr>\n <td>2</td>\n <td>0.027320</td>\n </tr>\n <tr>\n <td>3</td>\n <td>0.030205</td>\n </tr>\n <tr>\n <td>4</td>\n <td>0.027480</td>\n </tr>\n <tr>\n <td>5</td>\n <td>0.029770</td>\n </tr>\n </tbody>\n</table>\n\n<p>의에서 보였던 최악의 경우는 벗어났지만 수행시간이 늘어났다. 데이터의 셔플에서 수행시간을 까먹은 것으로 보인다. 최종적인 시간 복잡도는 \\(O(nlog_{2}n)\\)에서 벗어나지 않지만, \\(O(n)\\)을 갖는 셔플 과정을 포함하면서 미세한 성능차이를 보이는 듯 하다.</p>\n\n<p>다음으로 스택을 사용하는 퀵 정렬을 구현하고 피벗을 범위의 중간 값으로 선택하는 함수의 수행시간은 다음과 같다.</p>\n\n<ul>\n <li>스택 + 중간 요소가 피벗</li>\n</ul>\n\n<table>\n <thead>\n <tr>\n <th>시행</th>\n <th>시간</th>\n </tr>\n </thead>\n <tbody>\n <tr>\n <td>1</td>\n <td>0.007939</td>\n </tr>\n <tr>\n <td>2</td>\n <td>0.009103</td>\n </tr>\n <tr>\n <td>3</td>\n <td>0.009826</td>\n </tr>\n <tr>\n <td>4</td>\n <td>0.009826</td>\n </tr>\n <tr>\n <td>5</td>\n <td>0.008822</td>\n </tr>\n </tbody>\n</table>\n\n<p>위의 시도보다 평균적으로 놀라운 만큼 수행 시간 감소가 있었다. 의도적으로 정렬된 데이터를 입력으로 주었기 때문에 해당 퀵 정렬의 분할 함수는 항상 최고의 피벗을 선택할 것이고 이동시킬 데이터의 개수도 가장 적을 것이다. 하지만 여전히 최악의 경우가 존재한다. 선택한 배열 요소가 탐색 범위 내의 극단값이라면 여전히 비효율적인 분할이 발생할 것이다. 그리고 여전히, qsort보다 많은 시간을 사용한다.</p>\n\n<p>도대체 qsort는 어떤 방법을 썼길래 그렇게 안정적으로 적은 시간을 사용할 수 있을까? qsort 함수는 stdlib.h, C언어 표준 라이브러리에 정의되어있다. GNU C 라이브러리인 glibc를 참조하였다. glibc의 메뉴얼은 <a href=\"https://www.gnu.org/software/libc/manual/\">여기</a>에서 확인할 수 있다.</p>\n\n<p>glibc에는 stdlib.h가 있고 여기에 qsort 함수의 원형이 구현되어 있다. 다음은 그 원형이다.</p>\n\n<pre><code class=\"language-{.cpp}\">extern void qsort (void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar) __nonnull ((1, 4));\n</code></pre>  \n<p>정렬할 배열, 배열의 크기, 배열 요소의 크기, 배열을 비교할 비교 함수를 인자로 받는다. qsort의 용법에 대한 자세한 설명은 생략하겠다.</p>\n\n<p>또한 glibc의 stdlib에는 qsort.c가 구현되어 있다. 모든 <a href=\"https://code.woboq.org/userspace/glibc/stdlib/qsort.c.html\">소스코드</a>를 보이기에는 너무 길고 복잡하니 간단하게 먼저 주석을 확인해보았다.</p>\n\n<pre><code class=\"language-{.cpp}\">/* Order size using quicksort.  This implementation incorporates\n   four optimizations discussed in Sedgewick:\n   1. Non-recursive, using an explicit stack of pointer that store the\n      next array partition to sort.  To save time, this maximum amount\n      of space required to store an array of SIZE_MAX is allocated on the\n      stack.  Assuming a 32-bit (64 bit) integer for size_t, this needs\n      only 32 * sizeof(stack_node) == 256 bytes (for 64 bit: 1024 bytes).\n      Pretty cheap, actually.\n   2. Chose the pivot element using a median-of-three decision tree.\n      This reduces the probability of selecting a bad pivot value and\n      eliminates certain extraneous comparisons.\n   3. Only quicksorts TOTAL_ELEMS / MAX_THRESH partitions, leaving\n      insertion sort to order the MAX_THRESH items within each partition.\n      This is a big win, since insertion sort is faster for small, mostly\n      sorted array segments.\n   4. The larger of the two sub-partitions is always pushed onto the\n      stack first, with the algorithm then concentrating on the\n      smaller partition.  This *guarantees* no more than log (total_elems)\n      stack size is needed (actually O(1) in this case)!  */\n</code></pre>  \n<p>해당 소스 코드 주석에는 qsort 함수의 대략적인 구현 방법이 적혀있다. 간단하게 풀어쓰자면 다음과 같다.</p>\n\n<ol>\n <li>비-재귀적(스택)으로 구현하였다.</li>\n <li>세 값 중 중간값을 피벗으로 설정하였다.</li>\n <li>일정 크기 이하로 정렬할 파티션이 줄어들면 삽입 정렬을 하였다.</li>\n <li>피벗으로 나뉜 두 파티션 중 더 큰 파티션이 먼저 스택에 들어간다. 더 작은 파티션이 더 빨리 처리된다.</li>\n</ol>\n\n<p>위 내용을 중심으로 코드를 살펴보자.</p>\n\n<ul>\n <li>스택</li>\n</ul>\n\n<p>스택을 사용하여 퀵 정렬을 구현하는 것도 이전에 해보았다. 하지만 스택 관련 함수들을 호출하는 과정에서 성능하락이 나타났다. 결과적으로 재귀를 사용하여 구현한 퀵 정렬과 수행 시간에서 별 차이가 없었다. 하지만 qsort는 스택 함수들을 매크로로 구현하였다.</p>\n\n<pre><code class=\"language-{.cpp}\">#define STACK_SIZE\t(CHAR_BIT * sizeof (size_t))\n#define PUSH(low, high)\t((void) ((top-&gt;lo = (low)), (top-&gt;hi = (high)), ++top))\n#define\tPOP(low, high)\t((void) (--top, (low = top-&gt;lo), (high = top-&gt;hi)))\n#define\tSTACK_NOT_EMPTY\t(stack &lt; top)\n</code></pre>  \n\n<p>스택을 일반적인 구조체와 함수가 아닌 매크로로 구현함으로써 함수의 호출을 발생시키지 않아 성능 향상을 이루어냈다. 또한 필요없는 스택 연산들을 구현하지 않은 것도 볼 수 있다.</p>\n\n<ul>\n <li>피벗</li>\n</ul>\n\n<pre><code class=\"language-{.cpp}\">/* Select median value from among LO, MID, and HI. Rearrange\n\t     LO and HI so the three values are sorted. This lowers the\n\t     probability of picking a pathological pivot value and\n\t     skips a comparison for both the LEFT_PTR and RIGHT_PTR in\n\t     the while loops. */\n\n    char *lo = base_ptr;\n    char *hi = &amp;lo[size * (total_elems - 1)];\n    \n\t  char *mid = lo + size * ((hi - lo) / size &gt;&gt; 1);\n\n\t  if ((*cmp) ((void *) mid, (void *) lo, arg) &lt; 0)\n\t    SWAP (mid, lo, size);\n\t  if ((*cmp) ((void *) hi, (void *) mid, arg) &lt; 0)\n\t    SWAP (mid, hi, size);\n\t  else\n\t    goto jump_over;\n\t  if ((*cmp) ((void *) mid, (void *) lo, arg) &lt; 0)\n\t    SWAP (mid, lo, size);\n\tjump_over:;\n</code></pre>  \n\n<p>퀵 정렬은 근본적으로 그 최악의 경우를 졔외하지 못한다. 하지만 그 확률을 낮출 수 있다. 위 코드는 스택이 비어있지 않다면 매번 반복되며 정렬하고자 하는 범위에서 중간 값을 찾는 과정이다. 그 중간값은 median-of-three이며 파티션의 첫 번째 요소와 맨 끝 요소, 그리고 중간에 있는 요소 중 중간값을 찾는다. 그리고 해당 값이 파티션을 나눌 피벗이 된다. 만약 세 요소가 모두 극단값을 갖는다면 어쩔 수 없이 나쁜 피벗을 선택하게 된다. 하지만 그 확률을 충분히 줄일 수 있다. 전체 데이터 개수 \\(n\\)에 대하여 세 값이 모두 극단값일 확률은 \\(\\frac{1}{n^{3}}\\)이다. 단 하나의 값을 골랐을 때 그 값이 극단값일 확률이 \\(\\frac{1}{n}\\)인 것을 생각하면 확연히 적은 확률이고 따라서 상대적으로 믿을만한 피벗이라고 할 수 있다.</p>\n\n<ul>\n <li>단계의 축소</li>\n</ul>\n\n<p>가장 이상적인 모습의 퀵정렬은 \\(log_{2}n\\)의 단계를 가진다. 즉 정렬해야 할 파티션은 매 단계가 지날 때마다 두 배씩 늘어난다. 그렇다면 이 경우 맨 마지막 파티션 분열은 바로 그전 단계의 두 배가 될 것이며, 퀵 정렬만을 사용한다면 고작 2,3개의 요소를 갖는 파티션이지만 나누어야 하는 것이다. 요소가 몇 개 없는 배열을 정렬할 때 삽입정렬이 괜찮은 성능을 보이는 것을 고려하면, 파티션 분열 단계를 너무 깊이 들어가지 않고 일정 이상 요소를 갖는다면 이를 삽입정렬로 정렬하는 것이 성능 향상을 이끌어낼 것이다.</p>\n\n<details>\n<summary>해당 부분 소스코드</summary>\n<div>\n<pre><code class=\"language-{.cpp}\">  /* Once the BASE_PTR array is partially sorted by quicksort the rest\n     is completely sorted using insertion sort, since this is efficient\n     for partitions below MAX_THRESH size. BASE_PTR points to the beginning\n     of the array to sort, and END_PTR points at the very last element in\n     the array (*not* one beyond it!). */\n#define min(x, y) ((x) &lt; (y) ? (x) : (y))\n  {\n    char *const end_ptr = &amp;base_ptr[size * (total_elems - 1)];\n    char *tmp_ptr = base_ptr;\n    char *thresh = min(end_ptr, base_ptr + max_thresh);\n    char *run_ptr;\n\n    /* Find smallest element in first threshold and place it at the\n       array's beginning.  This is the smallest array element,\n       and the operation speeds up insertion sort's inner loop. */\n    for (run_ptr = tmp_ptr + size; run_ptr &lt;= thresh; run_ptr += size)\n      if ((*cmp) ((void *) run_ptr, (void *) tmp_ptr, arg) &lt; 0)\n        tmp_ptr = run_ptr;\n    \n    if (tmp_ptr != base_ptr)\n      SWAP (tmp_ptr, base_ptr, size);\n    \n    /* Insertion sort, running from left-hand-side up to right-hand-side.  */\n    \n    run_ptr = base_ptr + size;\n    while ((run_ptr += size) &lt;= end_ptr)\n      {\n    tmp_ptr = run_ptr - size;\n    while ((*cmp) ((void *) run_ptr, (void *) tmp_ptr, arg) &lt; 0)\n      tmp_ptr -= size;\n    \n    tmp_ptr += size;\n        if (tmp_ptr != run_ptr)\n          {\n            char *trav;\n    \n        trav = run_ptr + size;\n        while (--trav &gt;= run_ptr)\n              {\n                char c = *trav;\n                char *hi, *lo;\n    \n                for (hi = lo = trav; (lo -= size) &gt;= tmp_ptr; hi = lo)\n                  *hi = *lo;\n                *hi = c;\n              }\n          }\n      }\n  }\n</code></pre>  \n </div>\n</details>\n\n<ul>\n <li>나뉜 두 파티션 중 더 작은 파티션부터 계산한다.</li>\n</ul>\n\n<p>이는 결론적으로 스택의 크기가 \\(log_{2}n\\) 이하가 되는 것을 보장한다. 두 파티션 중 큰 파티션만 스택에 들어간다면, 정렬된 첫 번째 파티션이 등장할 때가 바로 스택에 가장 많은 파티션이 존재할 것이다. 정렬되어 정렬 대상에서 제외될 수록 스택의 필요 크기는 작아지게 된다. 그리고 정렬된 첫 번째 파티션이 등장할 때 가장 많은 파티션이 스택에 들어가는 경우는 모든 파티션이 균등하게 나누어졌을 때일 것이다. 균등하게 분할되지 않고 한쪽이 더 크다면 그만큼 작은 파티션이 생기고 따라서 정렬된 첫 파티션이 더 빨리 등장할 것이기 때문이다.</p>\n\n<p>예를 들어 16개의 요소를 가진 배열을 위 방법으로 정렬한다고 해보자. 모든 파티션은 균등하게 분배된다는 가정하에, 다음 단계를 거치게 될 것이다.</p>\n\n<table>\n <thead>\n <tr>\n <th style=\"text-align: center\">1단계</th>\n <th style=\"text-align: center\">2단계</th>\n <th style=\"text-align: center\">3단계</th>\n <th style=\"text-align: center\">4단계</th>\n </tr>\n </thead>\n <tbody>\n <tr>\n <td style=\"text-align: center\"> </td>\n <td style=\"text-align: center\"> </td>\n <td style=\"text-align: center\"> </td>\n <td style=\"text-align: center\">15</td>\n </tr>\n <tr>\n <td style=\"text-align: center\"> </td>\n <td style=\"text-align: center\"> </td>\n <td style=\"text-align: center\">13, 14</td>\n <td style=\"text-align: center\">13, 14</td>\n </tr>\n <tr>\n <td style=\"text-align: center\"> </td>\n <td style=\"text-align: center\">9, 12</td>\n <td style=\"text-align: center\">9, 12</td>\n <td style=\"text-align: center\">9, 12</td>\n </tr>\n <tr>\n <td style=\"text-align: center\">1, 8</td>\n <td style=\"text-align: center\">1, 8</td>\n <td style=\"text-align: center\">1, 8</td>\n <td style=\"text-align: center\">1, 8</td>\n </tr>\n </tbody>\n</table>\n\n<p>1단계에서는 파티션을 반으로 나누었다. 그 중 한 파티션을 계산하고 하나는 스택에 푸쉬했다. 2단계 역시 마찬가지이고, 3단계 역시 마찬가지이다. 4단계에서 16은 정렬된 파티션이고 15는 아직까지 정렬 여부를 확인하지 않았다고 가정했다. 처음의 파티션을 계속 반으로 나누는 과정이니, 마지막 단계의 총 파티션 수는 \\(log_{2}4\\)이다.</p>\n\n<p>그리고 직관적으로 알 수 있다시피 한 파티션이 다른 하나보다 크면 클수록 전체 파티션 수는 더욱 작아질 것이다. 이를 일반화하면 더 작은 파티션을 먼저 계산할 때, 가능한 최대 파티션 스택 개수는 \\(log_{2}n\\)이다. \n만약 qsort함수에서처럼 일정 범위 크기의 파티션은 선택정렬을 사용해 정렬한다면 어떻게 될까?</p>\n\n<p>위의 예시를 16개의 요소가 아닌 64개의 요소라고 가정하고 무조건적인 균등 분할이 이루어진다고 하자. 그렇다면 스택에 존재 가능한 총 파티션 수는 \\(log_{2}64 = 6\\)개일 것이다. 하지만 만약 4개 이하의 크기를 가진 파티션은 선택정렬을 한다면? 이는 곧 64개의 요소가 아닌 16개의 요소를 가진 배열을 정렬하는 것과 같다. 따라서 가능한 총 파티션 수는 \\(log_{2}(64/4) = 4\\)와 같다. 이를 전체 데이터 개수 n과 최소 파티션 크기 k에 대하여 일반화하면, 가능한 총 파티션의 수(=필요한 스택의 크기)는 \\(log_{2}(n/k)\\)이다.</p>\n\n<h2 id=\"마무리\">마무리</h2>\n\n<p>GNU C 라이브러리의 qsort는 살펴본 방법과 같이 구현되었고 꽤 좋은 성능을 보인다. 하지만 반대로 <a href=\"https://opensource.apple.com/source/xnu/xnu-7195.81.3/bsd/kern/qsort.c.auto.html\">Apple의 다윈(XNU)커널 BSD 부분</a>의 qsort는 스택이 아닌 재귀를 사용하여 구현되어있다. 재귀는 분명 스택 오버플로우의 위험을 내포하고 있지만, 위에서 보다시피 퀵 정렬에서 그 단계는 특정한 방법을 사용하여 \\(log_{2}n\\)이하로 줄일 수 있다. 따라서 극단적인 크기의 자료(일반적인 컴퓨터는 다 담을 수도 없을 정도의)를 정렬하는 것이 아니라면 걱정할 필요도 없이 안전한 범위의 재귀 단계만을 사용하게 된다. 이 qsort 또한 나중에 다루어보고 싶다.</p>\n\n<p>항상 내가 스스로 구현해보기 바쁜 나머지 남이 작성한 코드를 살펴보고 분석할 기회가 별로 없었다. 바퀴의 재발명도 필요하지만 남이 만든 바퀴를 분석하고 가져와서 쓸 줄도 알아야한다. 그런 점이 나름 힘든 경험이었다. 내가 작성하지 않은 코드가 너무 어색하고 눈에 잘 들어오지 않았다. 이런 어쩌면 쓸데없어 보이는 분석이 그런 내 약점을 보완해 줄 수 있지 않나 싶다.</p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/data_structure/","name":"2021-04-27-qsort.md","path":"post/data_structure/2021-04-27-qsort.md","url":"/post/data_structure/2021-04-27-qsort.html"},{"title":"연결리스트에서 탐색 빠르게 하기","excerpt":"연결리스트에서 탐색 빠르게 하기","categories":"data_structure","tags":["data_structure","algorithm","linked_list","indexing","search"],"toc":true,"toc_sticky":true,"date":"2021-05-10","layout":"default","content":"<h1 id=\"연결-리스트에서-index를-사용하여-빠르게-탐색하기\">연결 리스트에서 index를 사용하여 빠르게 탐색하기</h1>\n\n<p>연결 리스트는 간단하게는 선형 연결 리스트에서부터 복잡하게는 여러 트리까지 많은 곳에서 사용하는 자료 구조이다. C와 같은 로우레벨에서 자료들을 저장하고 삭제하는데 효과적이다. C에서 기본으로 제공하는 배열은 삽입과 삭제의 비용이 크지만 연결 리스트는 그렇지 않고 그 구조도 배열처럼 선형으로 구성하지 않고 다른 여러 방식으로 구성할 수 있다.</p>\n\n<p>하지만 C에서 연결 리스트를 직접 구현해보면 치명적인 단점을 발견하게 되는데, 기본적인 선형 연결 리스트에서 특정 노드를 탐색하는 방법은 순차 탐색 밖에 없다는 것이다. 중간에 있는 노드들을 곧바로 접근하지 못하니 이진 탐색은 그 비용이 너무 크다. 이런 점을 극복하기 위해 선형 연결 리스트가 아닌 트리로 구조를 바꾸면 탐색이 훨씬 빨라지지만, 일단은 선형 연결 리스트에서 탐색 속도를 빠르게 하는 방법을 알아보자.</p>\n\n<h2 id=\"색인\">색인</h2>\n\n<p>만약 연결 리스트를 항상 정렬된 상태로 저장한다고 하자. 노드의 삽입은 언제나 탐색 과정을 동반할 것이다. 하나의 노드를 삽입한다면 \\(O(n)\\)의 시간 복잡도를, n개의 노드를 삽입한다면 \\(O(n^2)\\)의 시간 복잡도를 갖는다. 노드의 삽입이 오래 걸리는 이유는 결국 탐색이 오래 걸리기 때문이고, 탐색이 오래 걸리는 이유는 탐색 방법이 순차 탐색이기 때문이다.</p>\n\n<p>논의 대상인 연결리스트의 노드는 다음과 같은 기본적인 구조를 갖는다고 하자.</p>\n\n<table>\n <tbody>\n <tr>\n <td>데이터</td>\n </tr>\n <tr>\n <td>다음 노드를 가리키는 포인터</td>\n </tr>\n </tbody>\n</table>\n\n<p>이런 노드를 갖는 연결리스트는 어쩔 수 없이 헤드에서부터 순차 탐색을 해야한다. 중간에 있는 노드를 접근할 방법이 없기 때문이다. 그렇다면 특정 노드들에 접근할 수 있는 노드 포인터들을 외부에 갖고 있다면 어떨까?</p>\n\n<table>\n <tbody>\n <tr>\n <td>node1</td>\n <td>node2</td>\n <td>node3</td>\n <td>node4</td>\n <td>node6</td>\n <td>node7</td>\n </tr>\n </tbody>\n</table>\n\n<p>6개의 정렬된 노드를 가진 연결 리스트가 있다. 우리가 node5라는, node4와 node6 사이에 삽입될 노드의 위치를 특정하고 싶다고 하자. node1을 가리키는 head만 갖고 있다면 최악의 경우 node1부터 node7까지 모든 노드를 순회해야 한다. 하지만 node4의 주소를 알고 있다면 어떻게 될까? 먼저 삽입하려는 node5와 node4를 비교한다. 삽입하려는 노드가 더 크므로 node4 아래의 노드들은 비교하지 않아도 된다. 따라서 탐색해야할 범위가 6개에서 3개로 줄게 된다.</p>\n\n<p>정렬된 노드들은 항상 어떤 기준으로 나누어질 수 있고 이를 보통 색인이라고 한다. 만약 1부터 100까지 저장되어 있다면 10, 20, 30, 40 등이 색인의 역할을 할 수 있다. 마치 사전에서 단어를 찾듯이, 어떤 숫자의 위치를 찾으려면 이 색인을 이용해서 찾을 수 있다. 46의 위치를 찾으려면 먼저 46이 어떤 색인에 해당하는지 알아야 한다. 십의 자리가 4이므로 탐색을 시작해야 할 색인은 40이다. 또한 십의 자리가 4라는 것은 50보다 작다는 것이므로 색인 50 이상의 숫자들은 탐색할 필요 없다. 따라서 46의 위치를 알기 위해서는 색인 40부터 50전까지만 탐색하면 된다.</p>\n\n<h2 id=\"색인의-구조\">색인의 구조</h2>\n\n<p>색인이 무슨 역할을 할 수 있는지 알았다. 그렇다면 색인은 어떻게 설계해야 할까?</p>\n\n<p>색인을 활용하여 하고 싶은 일은 결국 탐색이다. 찾고자하는 노드가 연결리스트에 존재하는지, 존재한다면 그 위치가 어디인지, 존재하지 않지만 새로 만들어 넣는다면 어디에 들어가야 하는지 알고싶다. 만약 노드의 존재 여부만을 알고 싶다면 노드 하나를 가리키는 단일 노드 포인터만으로도 충분히 특정 범위의 색인을 구현할 수 있다. 하지만 현재 연결리스트에 존재하지 않는 새 노드가 들어갈 위치를 탐색할 경우, 색인 범위의 바로 앞 노드도 가리켜야 한다.</p>\n\n<table>\n <thead>\n <tr>\n <th>node1</th>\n <th>node2</th>\n <th>node3</th>\n <th>node4</th>\n <th>node5</th>\n <th>node6</th>\n </tr>\n </thead>\n <tbody>\n <tr>\n <td>10</td>\n <td>11</td>\n <td>12</td>\n <td>22</td>\n <td>24</td>\n <td>27</td>\n </tr>\n </tbody>\n</table>\n\n<p>만약 위와 같은 연결 리스트가 존재한다고 하자. 색인은 두 개로, 10 값을 갖는 node1을 가리키는 1번 색인 하나와 22 값을 갖는 2번 색인 하나가 있다.</p>\n\n<table>\n <thead>\n <tr>\n <th>index1</th>\n <th>index2</th>\n </tr>\n </thead>\n <tbody>\n <tr>\n <td>node1</td>\n <td>node4</td>\n </tr>\n </tbody>\n</table>\n\n<p>여기서 24의 값을 갖는 노드가 존재하는지 찾는다면 index2를 참조하여 node4부터 탐색하면 된다. 하지만 만약 21의 값을 갖는 새 노드가 들어갈 자리를 찾는다면 어떨까?</p>\n\n<p>먼저 이 노드는 index2의 범위에 해당한다. 앞자리가 2이기 때문이다. 그래서 index2부터 탐색을 시작하였더니 index2가 가리키는 첫 노드 node4가 새 노드보다 크다. 그 말은 node4앞에, node3뒤에 새 노드가 들어간다는 뜻이다. 우리의 index2는 node4만을 가리킨다. 이중 연결 리스트라면 node4에서 손쉽게 node3의 위치를 참조할 수 있다. 하지만 위에서 보였던 것처럼 단일 연결 리스트로 구현되었다면 index2에서 node3의 위치를 특정할 방법이 없다. 하지만 새 노드를 node4앞에 삽입하기 위해서는 node3의 위치을 알아야 한다.</p>\n\n<p>이를 해결하기 위해 이중 연결 리스트를 사용할 수도 있다. 어찌보면 더 확장가능한 방법이라고 생각한다. 여기서는 색인의 구조를 달리하여 보았다. 만약 색인이 이 두 요소를 갖는 구조체로 정의된다면 조금 복잡하더라도 해결할 수 있다.</p>\n\n<table>\n <tbody>\n <tr>\n <td>index node 포인터</td>\n </tr>\n <tr>\n <td>이전 node 포인터</td>\n </tr>\n </tbody>\n</table>\n\n<p>index node는 위의 예시에서 node 4에 해당한다. 이전 node 포인터는 항상 index node 의 바로 앞 노드를 가리킨다. 이렇게 구성되어 있다면 우리는 색인 범위의 첫 노드로 새 노드를 삽입할 수 있다.</p>\n\n<h2 id=\"이전-노드를-가리키는-포인터\">이전 노드를 가리키는 포인터</h2>\n\n<p>어차피 이전 노드 포인터를 안다면 바로 그 뒤에 위치한 index 노드 포인터가 굳이 필요한지 궁금할 수 있다. 이에 대한 대답은 색인에 접근하는 방법 속에서 발견할 수 있다. 위의 예시에서 만약 앞자리가 3인 노드들을 가리키는 index3 색인과, 4인 노드들을 가리키는 index4 색인이 있다고 하자. 두 색인 범위에 노드가 하나도 없다면, 이 두 색인의 이전 노드 포인터는 모두 node6을 가리키고 있을 것이다.</p>\n\n<p>index3의 이전 노드 포인터의 다음 노드(색인 범위의 첫 노드)부터 index4의 이전 노드 포인터까지 탐색하면 새 노드의 위치를 특정할 수 있다. 만약 index3의 이전 포인터와 index4의 이전 포인터가 같은 주소를 가리킨다면 index3은 비어있다. 같은 주소가 아니라면 index4의 주소가 될 때까지 탐색하면 된다. 이를 통해 사실 index_node 자체는 필요하지 않다는 것을 알 수 있다. index_node는 before_node로부터 유도될 수 있다. 중요한 것은 before_node는 항상 특정 색인 범위 바로 앞에 존재하는 노드를 가리켜야 한다는 것이다.</p>\n\n<p>종합해 보자면 이제까지 설명한 방법은 결국 연결리스트의 각 부분을 나누는 것이라고 볼 수도 있다. 각 색인의 이전 노드는 각 연결리스트의 헤드에 해당하고 모든 연결리스트의 테일은 다음 연결리스트의 첫 노드를 가리키는 것이다. 결국 연결리스트에 색인을 추가하여 이를 이용해 탐색하는 것은 전체 데이터를 어떤 규칙으로 분류하여 작은 연결리스트 여러개에 나누어 저장하는 것과 다를 바 없다.</p>\n\n<h2 id=\"마치며\">마치며</h2>\n\n<p>인덱스를 구현하는 것은 탐색 알고리즘을 새로 구현하는 것이 아닌 탐색할 범위를 좁히는 과정에 불과하다. 과연 연결리스트 단독으로 방대한 양의 데이터를 저장하는 것이 올바른 것인지 의문이 들게 한다. 배열에 저장하여 관리하기 까다롭다면 트리를 사용하는 것이 더 가치있지 않나 싶다.</p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/data_structure/","name":"2021-05-10-Linked_list_searching_with_index.md","path":"post/data_structure/2021-05-10-Linked_list_searching_with_index.md","url":"/post/data_structure/2021-05-10-Linked_list_searching_with_index.html"},{"title":"AVL과 RB비교","excerpt":"AVL과 RB비교","categories":"data_structure","tags":["data_structure","algorithm","tree","AVL_tree","red-black_tree"],"toc":true,"toc_sticky":true,"date":"2021-06-26","layout":"default","content":"<h1 id=\"avl-트리와-red-black-트리-비교\">AVL 트리와 Red-Black 트리 비교</h1>\n\n<p>알다시피 트리의 높이는 곧 트리의 탐색시간을 결정한다. 이미 어떤 규칙에 의해 자식들로 나뉘는 트리에서 원하는 노드의 탐색 시간은 곧 일반적인 삽입과 삭제 시간 또한 결정한다. 따라서 트리가 어느 정도 편향되어 있는지, 자식 노드는 몇 개로 어떻게 구성되는지 같은 요소들은 트리의 전체적인 성능을 크게 좌우한다.</p>\n\n<p>자료구조의 시간적 복잡도를 고려하는 과정에서 최악의 경우를 고려하지 않을 수 없다. 가장 안 좋은 트리는 모든 노드가 형제를 갖지 않고 연결된 경우일 것이다. 극단적으로 편향된 이런 트리는 연결리스트와 거의 다를바 없다. 성능 또한 마찬가지일 것이다.</p>\n\n<p>다수의 데이터를 저장하기 위해 만들어진 자료구조인 만큼 이런 최악의 경우뿐만 아니라 ‘어느 정도 나쁜’ 경우도 고려를 해야한다. 이런 경우를 대처하기 위해 사용하는 이진 트리의 종류가 바로 AVL 트리와 Red-Black 트리다.</p>\n\n<p>이 글에서는 두 트리의 자세한 구성 방법은 다루지 않겠다. 각 트리의 자세한 내용은 다음 문서들을 참고하기 바란다.</p>\n\n<p><a href=\"https://ko.wikipedia.org/wiki/AVL_%ED%8A%B8%EB%A6%AC\">위키 백과 AVL 트리 항목</a></p>\n\n<p><a href=\"https://en.wikipedia.org/wiki/Red%E2%80%93black_tree\">영문 위키 백과 Red-Black 트리 항목</a></p>\n\n<h2 id=\"트리의-성능-측정\">트리의 성능 측정</h2>\n\n<p>두 트리를 비교하기 위한 방법은 무엇이 있을까? 데이터 관리의 측면에서 데이터 또는 데이터가 있어야 할 곳에 얼마나 빠르게 접근할 수 있느냐가 자료구조의 성능을 결정할 것이다. 이진 트리에서 노드에 접근하는 속도는 어떻게 결정되는가? 탐색하려는 노드가 어떤 높이(또는 깊이)에 위치해 있는지가 곧 그 노드를 탐색하는데 걸리는 시간을 결정한다. 이 시간을 트리 전체 노드에 일반화 시킬 수 있을까? 완전 이진 트리에서는 (절반 + 1) 개의 노드가 리프에 위치한다. 따라서 가장 큰 높이를 가진 리프의 높이가 곧 해당 트리에서 탐색하는 데 필요한 최악의 복잡도를 결정함과 동시에 이것을 다른 노드들에 일반화 시켜도 큰 무리가 없다고 하겠다.</p>\n\n<p>대단히 극단적으로 편향된 트리라면 리프의 높이가 다른 노드들의 복잡도를 대변할 수는 없지만 그런 트리는 이미 다른 노드들 조차 대단히 큰 높이를 갖고 있기 때문에 여기에서 고려하지 않는다.</p>\n\n<p>결론적으로 트리의 성능(시간적 복잡도)은 트리의 높이, 즉 가장 큰 높이를 가진 리프 노드의 높이가 결정한다. 반대로 말하자면 같은 높이일 때 더 많은 노드를 가지고 있을 수록 트리의 성능이 좋다. 다음과 같이 표현할 수 있을 것이다.</p>\n\n\\[SearchTime(T_1(h, n)) &lt; SearchTime(T_2(h+i, n))\\]\n\n\\[SearchTime(T_3(h, n)) == SearchTime(T_4(h, n+j))\\]\n\n<p>트리 \\(T_1\\)의 경우 \\(T_2\\)와 같은 수의 노드를 갖고 있지만 더 작은 높이를 갖기 때문에 탐색시간이 빠르다. 이는 당연하다.</p>\n\n<p>트리 \\(T_3\\)은 \\(T_4\\)와 같은 높이를 갖고 있지만 더 적은 노드를 갖고 있다. 탐색시간은 둘이 같은데, 탐색 시간은 노드의 개수와는 독립적이고 높이와 비례하기 때문이다. 그러나 트리 \\(T_4\\)는 \\(T_3\\)보다 더 효율적이다. 같은 탐색시간으로 더 많은 노드를 탐색할 수 있기 때문이다. 따라서 우리는 다음과 같은 명제를 얻을 수 있다.</p>\n\n<ul>\n <li>n이 같을 때, h가 작으면 빠른 트리다.</li>\n <li>h가 같을 때, n이 크면 효율적인 트리다.</li>\n</ul>\n\n<p>이것들은 뒤에 두 트리를 비교하는 도구로 사용될 것이다.</p>\n\n<h2 id=\"avl-트리-성능-측정\">AVL 트리 성능 측정</h2>\n\n<p>먼저 AVL트리의 성능을 측정해보자. AVL트리는 루트의 두 서브트리가 서로 2이상의 높이 차를 갖지 않도록 한다. 다시 말해 두 서브트리는 커봐야 1의 높이 차를 갖는다.</p>\n\n<p>위에서 보였다시피 트리의 성능을 측정하려면 극단적인 상황을 설정할 필요가 있다. 가장 편향된 AVL 트리를 구성한다. 아무리 편향된 AVL 트리라고 해도 두 서브트리는 1의 높이차를 가질 수 밖에 없다. \\(N(h)\\)가 높이 h의 편향된 AVL 트리가 갖는 노드 개수일 때, 3의 높이를 갖는 편향된 AVL 트리는 다음과 같은 노드 수를 가질 것이다.</p>\n\n\\[N(3) = N(2) + N(1) + 1\\]\n\n<p>두 서브트리는 2와 1의 높이를 갖고 최대 높이 차이인 1을 보인다. 두 서브트리의 노드 개수와 루트 노드 1을 더하면 편향된 AVL 트리의 전체 노드 개수를 구할 수 있다. 위 식은 재귀적으로 적용되는데,</p>\n\n\\[N(2) = N(1) + N(0) + 1\\]\n\n\\[N(1) = 1\\]\n\n\\[N(0) = 0\\]\n\n<p>위 식들을 일반화 해보면 다음과 같다.</p>\n\n\\[N(h) = N(h-1) + N(h-2) + 1, N(1) = 1, N(0) = 0\\]\n\n<p><a href=\"https://github.com/altair823/altair823.github.io/blob/master/post/data_structure/AVL_max_height.py\">파이썬으로 재귀함수를 구현하여 명령행 인자로 높이를 받아 편향된 AVL 트리의 전체 노드 개수를 출력하는 코드</a></p>\n\n<h2 id=\"red-black-트리-성능-측정\">Red-Black 트리 성능 측정</h2>\n\n<p>먼저 레드블랙 트리의 기본 가정들을 되짚고 넘어갈 필요가 있다.</p>\n\n<ol>\n <li>모든 노드는 레드, 또는 블랙의 값을 갖는다.</li>\n <li>새로 추가되는 노드는 레드 노드이고 루트는 항상 블랙이다.</li>\n <li>레드 노드는 연속으로 존재할 수 없다.</li>\n</ol>\n\n<p>이와 같은 특징들과 노드의 회전으로 인해 레드블랙 트리는 특별한 규칙 하나를 만들어 낸다.</p>\n\n<p><strong>루트에서부터 모든 리프 노드까지 가는 경로에 만나는 블랙 노드의 개수는 항상 같다.</strong></p>\n\n<p>따라서 만약 가장 불균형한 레드블랙 트리가 존재한다면, 레드 노드가 한 쪽 방향으로만 존재하고 나머지 노드들은 블랙 노드인 트리가 될 것이다. 다시 말해, 루트부터 가장 큰 높이를 가진 리프 노드까지 가는 경로에만 레드 노드가 존재하고 그 외의 다른 노드들이 모두 블랙이라면 가장 불균형하다. 이는 다음과 같은 레드블랙 트리의 특징을 이끌어낸다.</p>\n\n\\[MAX_H &lt;= 2MIN_H\\]\n\n<p>제일 큰 높이를 가진 리프까지의 경로에는 모든 블랙 노드들 사이에 레드 노드가 끼워져 있을 것이고(\\(MAX_H = BN + RN\\)), 가장 작은 높이를 가진 리프까지의 경로에는 블랙 노드만 존재할 것이다(\\(MIN_H = BN\\)). 루트 노드를 경로에 포함하지 않는다면, \\(BN\\)과 \\(RN\\)의 관계는 다음과 같다.</p>\n\n\\[RN = BN\\]\n\n<p>따라서 \\(MAX_H = 2BN\\) 이고 이는 위 특징을 만족한다. 그렇다면 특정 높이에서 존재할 수 있는 노드는 최소 몇 개일까?</p>\n\n<p>가장 불균형한 레드블랙 트리에서 높이 \\(h\\)에 대하여 루트에서부터 가장 큰 높이를 갖는 리프까지의 경로에 존재하는 블랙 노드의 개수는 \\(h/2\\)일 것이다. 루트에서부터 이에 반대편 서브트리는 모든 노드가 블랙인 완전 이진 트리가 되고 그 높이는 \\(h/2\\)일 것이다. 왜냐하면 루트부터 모든 리프까지 블랙 노드의 개수는 같아야 하기 때문이다.</p>\n\n<p>이런 방식으로 가장 큰 높이의 리프 노드까지의 경로에 있는 반대편 이진 트리를 모두 정의할 수 있다. 최대 높이가 7일 때 가장 불균형한 레드블랙 트리의 모습은 다음과 같다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123512949-3de12a00-d6c5-11eb-92a7-d9c99919b075.jpeg\" alt=\"unbalanced red-black tree\" style=\"zoom:75%;\" /></p>\n\n<p>최장 높이 경로에서 각각의 서브 루트에 매달린 완전 이진 트리의 높이에 유의하라. 해당 서브 루트부터 리브까지의 블랙 노드 개수는 모두 같아야 하기 때문에 위의 높이를 보인다.</p>\n\n<p>높이가 하나 증가할 때마다 포화 이진트리가 하나와 루트 노드 하나가 증가되니 높이에 따른 최소 노드 개수는 다음과 같이 구할 수 있다.</p>\n\n\\[N(h) = N(h-1) + 2^{((h-1)/2)}\\]\n\n<p><a href=\"https://github.com/altair823/altair823.github.io/blob/master/post/data_structure/red_black_height.py\">파이썬으로 구현한 Red-Black 트리의 높이에 따른 최소 노드 개수를 출력하는 코드</a></p>\n\n<h2 id=\"두-트리의-비교\">두 트리의 비교</h2>\n\n<p>각 높이에 따른 최소 노드 개수를 비교해보았다.</p>\n\n<table>\n <thead>\n <tr>\n <th>높이</th>\n <th style=\"text-align: center\">AVL Tree</th>\n <th style=\"text-align: center\">Red-Black Tree</th>\n </tr>\n </thead>\n <tbody>\n <tr>\n <td>1</td>\n <td style=\"text-align: center\">1</td>\n <td style=\"text-align: center\">1</td>\n </tr>\n <tr>\n <td>2</td>\n <td style=\"text-align: center\">2</td>\n <td style=\"text-align: center\">2</td>\n </tr>\n <tr>\n <td>3</td>\n <td style=\"text-align: center\">4</td>\n <td style=\"text-align: center\">4</td>\n </tr>\n <tr>\n <td>4</td>\n <td style=\"text-align: center\">7</td>\n <td style=\"text-align: center\">6</td>\n </tr>\n <tr>\n <td>5</td>\n <td style=\"text-align: center\">12</td>\n <td style=\"text-align: center\">10</td>\n </tr>\n <tr>\n <td>6</td>\n <td style=\"text-align: center\">20</td>\n <td style=\"text-align: center\">14</td>\n </tr>\n <tr>\n <td>7</td>\n <td style=\"text-align: center\">33</td>\n <td style=\"text-align: center\">22</td>\n </tr>\n <tr>\n <td>8</td>\n <td style=\"text-align: center\">54</td>\n <td style=\"text-align: center\">30</td>\n </tr>\n <tr>\n <td>9</td>\n <td style=\"text-align: center\">88</td>\n <td style=\"text-align: center\">46</td>\n </tr>\n <tr>\n <td>10</td>\n <td style=\"text-align: center\">143</td>\n <td style=\"text-align: center\">62</td>\n </tr>\n </tbody>\n</table>\n\n<p>입력이 편향되었을 때, AVL트리가 같은 높이에서 레드블랙 트리보다 더 많은 노드를 담을 수 있다. 즉, 같은 노드를 더 작은 높이에서 담을 수 있다는 뜻이며 이는 AVL트리가 더 짧은 탐색시간을 가진다는 것이다. 같은 개수의 노드가 존재할 때 AVL트리에서의 탐색이 더 빠를 것이다.</p>\n\n<p>하지만 실제로 구현하여 운영해보면 알겠지만 AVL트리는 레드블랙 트리보다 많은 노드 재배치를 실행한다. 레드블랙 트리는 레드 노드가 연속해서 존재할 경우에만 노드 재배치를 실행하며 레드 노드의 네 가지 중복 경우 중 두 가지는 더 이상 루트를 향해 올라가지 않아도 된다. 반대로 AVL 트리는 단 2의 높이 차도 허락하지 않으며 비교적 빈번한 현재 노드 재배치와 부모로 올라가는 재배치를 요구한다. 이는 AVL트리가 레드블랙 트리보다 삽입과 삭제에 더 많은 시간을 소모하게 만든다.</p>\n\n<p>조금 쓸데없이 깊이 들어간 감이 없지않아 있지만, 간단하게 다음과 같이 결론 내릴 수 있다.</p>\n\n<ul>\n <li>AVL트리는 비교적 빠른 탐색 시간을 갖지만 삽입과 삭제에 더 시간이 걸린다.</li>\n <li>레드-블랙 트리는 비교적 빠른 삽입, 삭제를 할 수 있지만 탐색에 더 시간이 걸린다.</li>\n</ul>\n\n<p>그렇다면 어떤 트리를 언제 쓰는 것이 더 유리할까?</p>\n\n<h2 id=\"트리의-선택\">트리의 선택</h2>\n\n<p>교과서적으로 접근하면 답은 간단하다. 삽입, 삭제가 적지만 탐색이 많을 경우 AVL트리를, 반대의 경우 레드블랙 트리를 선택하면 된다. 하지만 궁금하다. 그 차이가 어느 정도일까?</p>\n\n<p>높이 40에서 두 트리가 가장 불균형할 때 존재하는 모든 노드의 개수를 구하여 보았다. 재귀적으로 구현한 함수라 시간이 좀 걸렸지만 결과는 다음과 같다.</p>\n\n\\[AVL_N(40) = 267914295\\]\n\n\\[REDBLACK_N(40) = 2097150\\]\n\n<p>가장 불균형한 경우이기 때문에 두 트리의 노드 수가 극단적으로 차이나는 것을 볼 수 있다. 높이 40의 불균형한 레드블랙 트리의 노드 개수는 높이 30의 불균형한 AVL트리의 노드 개수와 거의 동일했다(2178308).</p>\n\n<p>만약 아주 많은 데이터를 아주 많이 탐색해야 하는 경우, 그리고 대부분의 데이터가 미리 저장되고 그 이후에 탐색을 하는 경우 AVL트리는 레드블랙 트리에 비해 훨씬 더 좋은 성능을 보장할 것이다. 데이터의 삽입과 삭제가 최소화되면 될 수록 사용자가 경험하는 분할상환시간이 적어질 것이다.</p>\n\n<p>반대로 데이터가 언제 들어올지 예측 불가능하고 그 수가 그렇게 극단적으로 많지 않은 경우 레드블랙 트리가 더 유리할 것이다. 만약 어떤 학원에서 원생들의 정보를 트리에 저장하려고 한다고 상상해보자. 입소문이 나거나 광고를 하기 전까지 원생은 크게 늘어나지 않을 가능성이 높다. 반대로 학생들이나 엄마들 사이에 소문이 돌거나 대대적인 광고를 한 이후에는 원생들이 갑자기 많이 들어올지 모른다. 즉, 언제 얼마나 데이터가 입력될지 알 수 없다. 하지만 한 가지는 확실하다. 2억 명이 학원에 등록하려고 오지는 않을 것이라는 사실이다. 학원의 크기에 따라 다르겠지만 정말 많아봐야 몇 백명, 전국구에 있는 학원이라봐야 몇 천명 일 것이다. 게다가 학생들의 정보를 자주 열람할 이유도 없다. 오히려 학생들이 등록하고 해지하는 과정에서 정보의 삽입과 삭제가 더 빈번히 일어날 것이다. 이런 경우 많은 연산이 필요한 AVL트리를 사용할 이유가 없다.</p>\n\n<h2 id=\"마치며\">마치며</h2>\n\n<p>내가 봤던 책에서는 위에서 두 트리를 비교하며 언급했던 간단한 결론만 내리고는 했다. 하지만 구체적으로 데이터가 얼마나 많아야 AVL트리를 선택할 만큼 시간적 복잡도를 차이나게 하는지, 어느 정도의 데이터가 탐색시간의 차이를 감수하고라도 레드블랙 트리를 선택하게 하는지 알 수 없었다.</p>\n\n<p>기말고사가 끝난 이번 기회에 두 트리에 대한 더 깊은 이해를 할 수 있었다. 다음에는 B-트리나 B+트리도 한 번 다루어보고 싶다.</p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/data_structure/","name":"2021-06-26-Tree.md","path":"post/data_structure/2021-06-26-Tree.md","url":"/post/data_structure/2021-06-26-Tree.html"},{"title":"미로의 자료구조","excerpt":"미로의 자료구조","categories":"data_structure","tags":["data_structure","graph","maze"],"toc":true,"toc_sticky":true,"date":"2021-07-13","layout":"default","content":"<h1 id=\"미로의-자료구조\">미로의 자료구조</h1>\n\n<p>학기 중에 미로를 저장하고 최단 경로를 탐색하는 과제가 있었다. 당시에는 스택까지만 배운 상태여서 배열에 미로를 저장하였다. 하지만 이번에 미로를 생성하는 알고리즘을 구현하면서 더 이용하기 편한 형태로 미로를 저장할 기회가 있었다. 바로 그래프의 형태로 구현하는 것이다. 이에 대하여 설명하고자 한다. 지나갈 수 있는 칸과 그렇지 않은 칸들로 이루어진 형태의 미로는 다루지 않겠다.</p>\n\n<h2 id=\"배열로-저장하기\">배열로 저장하기</h2>\n\n<p>인간이 바라보는 미로 자체에는 크게 복잡한 정보가 존재하지는 않는다. 단 두가지, 지나갈 수 있는 통로와 지나갈 수 없는 벽이 존재할 뿐이다. 칸을 모두 저장하면서 각 칸의 네 벽에 대한 정보를 저장하는 것은 분명 낭비가 있어보인다. 인접한 두 칸에서 저장한 정보가 겹치기 때문이다. 같은 값을 두 칸이 모두 저장할 필요가 있을까?</p>\n\n<h3 id=\"구현\">구현</h3>\n\n<p>가로 x개, 세로 y개의 칸을 갖는 미로는 다음과 같은 개수의 벽을 갖는다.</p>\n\n\\[x 개의 가로 벽 * (y +1) + (x+1 개의 세로 벽) * y\\]\n\n<p>따라서 가로 벽과 세로 벽을 각각 배열로서 저장할 수 있다. 가로 벽 배열을 \\(H\\), 세로 벽 배열을 \\(V\\)이라고 할 때, 칸 \\((x, y)\\)을 둘러싼 벽은 다음과 같이 구할 수 있다(\\(0 &lt;= x, 0 &lt;= y\\)이며 모두 \\(0\\)부터 시작한다면).</p>\n\n<p>위쪽 벽: \\(H[y][x]\\)</p>\n\n<p>아래쪽 벽: \\(H[y+1][x]\\)</p>\n\n<p>왼쪽 벽: \\(V[y][x+1]\\)</p>\n\n<p>오른쪽 벽: \\(V[y][x+1]\\)</p>\n\n<p>정확한 인덱스는 다를 수 있지만 중요한 것은 함수 하나를 구현하면 단지 벽만을 저장했음에도 칸의 좌표를 통해 벽에 접근할 수 있다는 것이다. 탐색 알고리즘은 단지 좌표로 미로를 탐색할 수 있다.</p>\n\n<h2 id=\"그래프로-저장하기\">그래프로 저장하기</h2>\n\n<p>한 편으로 미로는 그 자체로 그래프라고 생각할 수 있다. 칸은 정점이며 통로는 옆 정점으로 갈 수 있는 간선다. 따라서 벽은 무한한 가중치를 갖는 간선이다. 모서리를 제외한 모든 칸은 4개의 인접한 정점을 가질 수 있다. 인접한 두 정점에 서로로 갈 수 있는 간선을 저장하는 것은 양방향 간선을 뜻한다. 이는 특별한 규칙이 없는 이상 양방향으로 이동할 수 있다는 통로의 정의에 부합한다. 간선의 방향에 따라 다른 가중치를 부여하거나 일방향 간선으로 만드는 것은 특정 방향이 더 가기 쉽게 만들거나 일방통행으로 만들 수 있다.</p>\n\n<p>현실의 길찾기를 생각해보자. 길찾기는 미로 탐색의 변형이라고 할 수 있다. 길은 여러 개일 수 있지만 어떤 길은 여러 이유로 선호되지 않고, 어떤 길은 선호된다. 그래프의 가중치가 이 역할을 한다. 만약 미로 그래프에서 각 간선이 서로 다른 가중치를 갖는다면 최단경로 탐색 알고리즘은 여러 경로 중에 가장 비용이 적은 경로를 선택할 것이다. 비록 그 경로가 일반적인 미로에서의 경로와는 다르겠지만 말이다.</p>\n\n<p>통로에 아무런 가중치가 없는 미로에서 다익스트라 알고리즘은 나쁜 성능을 보인다. 그것은 마치 BFS 탐색과 다를 바 없을 것이다. 하지만 만약 통로에 가중치가 부여된다면 DFS, BFS를 뛰어넘는 성능의 여러 알고리즘을 사용할 수 있을 것이다.</p>\n\n<h3 id=\"구현-1\">구현</h3>\n\n<p>미로에 한정한다면, 모든 칸은 인접한 네 개의 칸을 갖는다(모서리 칸들은 그렇지 않다는 것에 주의하자). 따라서 방향에 따른 칸 포인터 배열로 이를 정의할 수 있다. 또한 방향에 따른 가중치 배열을 정의하여 가중치를 줄 수 있다. 칸 \\(V(x, y)\\)의 오른쪽 간선과 가중치는 다음과 같이 얻을 수 있다.</p>\n\n<p>adjacentVertex[direction] , weight[direction] (0 &lt;= direction &lt; 4)</p>\n\n<h2 id=\"마치며\">마치며</h2>\n\n<p>미로를 배열이 아닌 그래프로 저장하면 더 많은 공간을 필요로 한다. 배열로 저장할 때 (열림 혹은 닫힘 플래그 비트)\\(* 2xy + x + y\\)의 공간을 차지한다면, 그래프로 저장할 때는 (\\(x\\)좌표 정수 + \\(y\\)좌표 정수 + \\(4*\\)정점 포인터 + \\(4*\\)가중치 변수)\\(* xy\\)의 공간을 필요로 한다. 대강 가늠해도 더 많은 공간을 차지함을 알 수 있다.</p>\n\n<p>하지만 사실 공간이 부족할 만큼 큰 미로를 생성할 일은 별로 없다. 더군다나 단방향 간선이나 방향에 따라 가중치를 다르게 줄 수 있는 그래프가 개인적으로는 더 매력적으로 다가온다.</p>\n\n<p>미로의 칸을 배열로 구현한 코드는 <a href=\"https://github.com/altair823/Data_Structure/blob/master/%EB%AF%B8%EB%A1%9C%ED%83%90%EC%83%89.c\">여기</a>에서, 그래프로 구현한 코드는 여기<a href=\"https://github.com/altair823/SPA_compare/blob/main/map/Location.h\">(헤더)</a><a href=\"https://github.com/altair823/SPA_compare/blob/main/map/Location.cpp\">(구현)</a>에서 볼 수 있다.</p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/data_structure/","name":"2021-07-13-maze_structure.md","path":"post/data_structure/2021-07-13-maze_structure.md","url":"/post/data_structure/2021-07-13-maze_structure.html"},{"title":"리눅스 민트 설치 후기 1","excerpt":"리눅스 민트 설치 후기 1","categories":"extra","tags":["linux","linux mint","open source","OS"],"toc":true,"toc_sticky":true,"date":"2021-05-10","layout":"default","content":"<h1 id=\"리눅스-민트-설치-후기-1\">리눅스 민트 설치 후기 1</h1>\n\n<h2 id=\"리눅스-민트\">리눅스 민트</h2>\n\n<p>라즈베리파이를 저번 겨울 내내 주물럭 거렸다. 처음에는 정말 어색하고 어렵게만 느껴졌던 리눅스의 터미널은 온갖 오류들을 잡고, 새로운 프로그램을 설치하며, GUI가 없는 라즈베리파이 OS Lite의 폴더들을 이동하는 과정에서 정말 친숙한 도구가 되었다. 라즈베리파이와 구르다보니 어느 새 리눅스가 익숙해졌다.</p>\n\n<p>이번에 어머니가 새로 노트북을 장만하면서 사용하지 않는 노트북이 내 손에 들어왔다. 언젠가 리눅스 계열 운영체제를 제대로 써보고 싶던 나는 그 구형 노트북에 여러 OS를 깔아 사용해보았다. 우분투부터 시작해서 데비안, 아치 리눅스까지 깔아 사용해봤다. 노트북 사양이 낮다보니 우분투 같이 비교적 무거운 OS는 사용하기 힘들었다. 그렇다고 아치를 쓰자니 그동안 데비안 기반인 라즈비안만 써왔던 나에게 아치는 너무 어려웠다. AUR는 굉장히 흥미롭고 아치를 써보고 싶을만큼 매력적이었지만 대학 과제와 여러 중요한 작업들을 당장 해야하는 나는 어쨌든 그렇게 지원이 불안정한 OS를 사용할 수 없다고 결론 내렸다. 게다가 아치에 그놈을 깔아 쓰자니 이게 우분투와 다른게 뭔지 싶기도 했다.</p>\n\n<p>그 다음으로 온 것이 리눅스 민트이다. 결론적으로 말하자면 이 리눅스 민트를 내 데스크탑에도 설치하게 되었다. 내가 리눅스 민트를 선택한 이유는 다음과 같다.</p>\n<ol>\n <li>\n <h4 id=\"익숙하다\">익숙하다.</h4>\n <p>여태 ‘sudo apt’를 터미널에 주구장창 타이핑해 온 내 입장에서 같은 패키지 관리자와 저장소를 쓸 수 있다는 것은 굉장히 중요했다. 새로 무언가를 처음부터 배우는 것도 좋지만 지금은 당장 해야할 일들도 남았고 무엇보다 데스크탑을 반드시 사용할 일들이 있었다. 이런 상황에서 pacman이니 yam이니 하는 것들을 새로 배우는 시간을 갖기 싫었다.</p>\n </li>\n <li>\n <h4 id=\"많은-사용자\">많은 사용자.</h4>\n <p>물건의 사용자가 많다는 것은 그것이 가장 좋은 물건임을 뜻하지는 않지만 절대 나쁜 물건이 아니라는 뜻이다. 이 룰은 특히 소프트웨어에 깊이 적용되어 왔다. 사용자가 많을수록 많은 개발자가 참여하고 오픈소스 프로그램 입장에서 이는 굉장히 중요한 요소가 된다. 책임의 소재가 불분명한 경우 프로그램의 퀄리티는 많은 기여가 좌우한다. 또한 사용자가 많다는 것은 문제가 발생했을 때 물어볼 선생님들도 많다는 것을 뜻한다. 리눅스 민트는 비교적 인기가 많은 배포판에 속한다. 이런 조건에 적절히 부합했다.</p>\n </li>\n <li>\n <h4 id=\"비교적-가볍고-빠르다\">비교적 가볍고 빠르다.</h4>\n <p>macOS를 사용하면서 불만이 있었다면 그것은 바로 버벅임이었다. 물론 많은 프로그램들이 백그라운드에서 항상 돌아가고, 자주 재시동하지도 않으면서, 성능이 그렇게 뛰어나지도 않고, 결정적으로 인텔의 노트북 CPU가 탑재된 내 맥북의 버벅임은 받아들여야하는 트레이드 오프였다. 하지만 인정한다고 해서 맥북이 빨라지는 것은 아니니, 항상 안정적이고 빠른 시스템을 욕망해왔다. 바닥부터 새로 쌓을 수 있는 리눅스를 설치하는 김에 빠릿하고 가벼운 운영체제를 써보고 싶었다. 아치도 그런 차원에서 설치해 사용해보았다.</p>\n </li>\n <li>\n <h4 id=\"사용자-친화적이다\">사용자 친화적이다.</h4>\n <p>아무리 컴퓨터를 좋아하고 깊은 지식이 있다고 해도 GUI를 좋아하는 것은 인간의 천성이다. 인간은 역사상 단 한번도 GUI가 아닌 것을 만져본 적이 없기 때문이다. 아무리 내가 터미널에 익숙해졌다고 해도 모니터를 덮은 검은 화면에 초록색 글자 몇 개는 너무 불친절했다. 궁금한 것이 생겨도 브라우저 하나 켤 수 없는 TUI 환경은 내 입장에서 절대 일반적인 목적으로 사용할 수 없었다. 당장 해야할 일이 있으니 어느 정도 희생은 하더라도 기존에 사용하던 맥, 윈도우처럼 GUI를 갖고 있기를 바랬다. 설치 후에 알게된 것들이지만 기본으로 넣어준 스냅샷 기능이나 화면 캡쳐 기능 같은 것들도 굉장히 고마웠다.</p>\n </li>\n <li>\n <h4 id=\"디자인이-괜찮다\">디자인이 괜찮다.</h4>\n <p>솔직히 리눅스 배포판들의 UI 디자인은 구리다. 20년 전 컴퓨터에서 가져온 것 같은 아이콘들에 차가운 작업표시줄, 뭔 듣도 보도 못한 기능들까지, 리눅스의 과거 경험들은 썩 아름답지 못했다. 개인적으로 우분투의 UI도 마음에 안 들었는데 아이콘들은 멋지지만, 내가 지금 데스크탑을 만지고 있는지, 아니면 싸구려 태블릿 PC를 만지고 있는지 모를 정도였다. 리눅스 민트는 그런 면에서 개인적으로 꽤 괜찮은 수준의 디자인을 보여주었다. 지금에 와서는 맥을 따라한 테마들을 마구 적용해 사용 중이지만 그렇지 않더라도 맥이나 윈도우와 크게 다르지 않은 세련된 디자인이 마음에 들었다.</p>\n </li>\n</ol>\n\n<h2 id=\"일주일간-사용해본-후기\">일주일간 사용해본 후기</h2>\n\n<p>솔직히 이제와서 생각해보면 고사양 데스크탑에 어떤 OS를 깔아도 이것과 크게 다르지 않을 것이라 생각한다. 분명 민트는 빠르지만 구형 노트북에서 최신 라이젠 데스크탑으로 온 순간부터 ‘누가누가 빠르나요’는 더 이상 의미 없어 보인다. 뭘 해도 빠르기 때문이다.</p>\n\n<p>로지텍에서 드라이버를 지원해주지 않는 것도 안타까운 부분이다. 게이밍 마우스의 버튼에 여러 기능을 할당해 사용하고 있었지만 정식으로 지원하는 로지텍 마우스 드라이버가 없어서 그 기능들을 사용하지 못하고 있다. 맥과 윈도우에서는 KM 스위치를 사용해 왔다갔다 하며 잘 쓰고 있었지만 스위치 문제인지 민트에서는 그런 기능 키들이 먹히질 않는다.</p>\n\n<p>연장선상의 이야기지만 이렇게 제조사에서 지원을 해주지 않는 문제가 일반사용자의 발목을 잡는다. 한글(hwp)이라는 특수한 워드 프로세서로 갈라파고스화 된 한국에서 한글 문서를 편집할 수 없다는 것은 또한 굉장히 불편함을 준다. 깃헙에 한글 문서를 편집하고 읽을 수 있는 프로그램이 올라와 있긴 하지만 개인들이 제작하는 특성상 안정성을 보장할 수 없고 지속적인 업데이트 또한 불투명한 것이 현실이다. 제조 기업 차원에서 프로그램을 지원하는 윈도우와는 달리 특별한 이유가 없으면 지원해주지 않는 리눅스 환경은 분명 자유롭지만 이는 마치 야생에서 자유로운 비문명인이 된 기분이다.</p>\n\n<p>하지만 반대로 컴퓨터에 뜻이 있는 입장에서 리눅스는 편한 구석도 많다. 프로그래밍과 관련된 툴은 거의 대부분 리눅스를 지원한다. 패키지 관리자로 인해 설치까지 더 편한 경우도 많다. 남들이 홈페이지 찾아가서 exe나 pkg를 다운받을 때 나는 터미널에서 몇자 치면 알아서 설치까지 해주니 말이다.</p>\n\n<p>공부도 많이 된다. 라즈베리파이부터 지금까지 여러 리눅스를 사용하면서 리눅스 자체에 익숙해졌고 그 장단점도 어느 정도 알게되었다. 이번에 진행한 프로젝트 과제 중에 터미널로 .java 파일을 컴파일하고 .jar로 만들어 제출하라는 교수님의 요구사항이 있었다. 많은 학생들이 생소해 했고 이메일로 받은 질문도 많았다고 교수님이 말씀하셨다. 하지만 운 좋게도 터미널에서 굴러본 나는 딱히 어렵지 않게 과제를 수행할 수 있었다.</p>\n\n<p>이상은 리눅스 민트 보다는 리눅스 배포판 전체가 공유하는 부분이라고 생각한다. 개인적으로 다른 배포판과 비교되는 리눅스 민트만의 특별한 구석을 잘 모르겠다. 당연하게도 일반적인 사용을 목적으로 두고 만들어졌기 때문이다. 만약 친구가 ‘리눅스를 깔아보고 싶은데 어떤걸 써야할지 모르겠어’라고 한다면 가장 대중적인 우분투와 더불어 리눅스 민트를 추천해줄 것이다. 가장 익숙할 테니까. 하지만 이것만 계속 쓰라고 할 수는 없을 것 같다.</p>\n\n<p>어찌되었던 오픈소스인 이상 리눅스 민트를 포함한 리눅스 계열 OS는 끊임없이 변화한다. 어찌보면 macOS나 윈도우보다 더. 그것이 내가 리눅스를 쓰게되는 가장 큰 매력이다. 지금이 마음에 들지 않거나 더 마음에 드는 OS가 나타나면 언제든지 옮겨갈 수 있는 자유, 그것이 리눅스를 계속 쓰게되는 이유인 것 같다.</p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/extra/","name":"2021-06-02-Linux_mint_review_1.md","path":"post/extra/2021-06-02-Linux_mint_review_1.md","url":"/post/extra/2021-06-02-Linux_mint_review_1.html"},{"title":"리눅스 민트 설치 후기 2","excerpt":"리눅스 민트 설치 후기 2","categories":"extra","tags":["linux","linux mint","open source","OS"],"toc":true,"toc_sticky":true,"date":"2021-06-21","layout":"default","content":"<h1 id=\"리눅스-민트-설치-후기-2\">리눅스 민트 설치 후기 2</h1>\n\n<p>마지막으로 글을 쓴지 거의 한달이 다 되어 가는 것 같다. 기말고사 시즌이라 시험 준비에 바빴기 때문이다.</p>\n\n<p>그동안 리눅스 민트를 쓴 경험을 다시 한 번 다루고자 한다.</p>\n\n<h2 id=\"그동안-별로-안썼다\">그동안 별로 안썼다</h2>\n\n<p>리눅스가 대단하고 매력적인 것도 맞고 리눅스 민트가 우아하고 빠른 것도 맞지만 사실 시간이 지나면서 점점 안쓰게 되었다. GRUB 화면에서 윈도우를 선택하는 것이 익숙해졌다. 코딩할 때는 리눅스에 있는 것들이 모두 있고 더 편한 환경들도 제공되는 맥을 썼다. 한 달여 기간 동안 리눅스 민트를 쓰면서 느꼈던 리눅스만의 단점을 (정확하게는 리눅스 민트의 단점을) 말해보고자 한다.</p>\n\n<h2 id=\"굳이\">굳이?</h2>\n\n<p>리눅스를 좋아하는 사람들에게는 안타깝지만 사실 ‘리눅스만’ 할 수 있는 일을 거의 없다. 언제나 ‘리눅스도’ 할 수 있는 것들만 있다. 오히려 ‘리눅스라’ 못하는 일들이 있을 뿐이다. 특히 요즘처럼 코딩이 아닌 시험공부를 할 때는 굳이 아래에서 후술할 단점을 갖는 리눅스 민트를 윈도우나 맥 대신 써야할 이유를 느끼지 못했다. 고작 pdf나 워드 문서들이나 읽고 외워야 하는 사람 입장에서 터미널이나 패키지 관리자가 무슨 의미를 갖는다는 말인가?</p>\n\n<p>그나마 pdf 같은 문서 파일들이 빠릿빠릿하게 열리는 것은 봐줄만 했다.</p>\n\n<h2 id=\"버그가-많다\">버그가 많다</h2>\n\n<p>이번 학기 기말고사는 대부분 과목이 줌 앱으로 영상을 켜고 나를 찍는 동시에 컴퓨터로 학교 홈페이지로 들어가 문제를 풀고 인터넷으로 제출하는 형식이었다. 나는 이 과정에서 리눅스 민트를 사용할 마음이 조금도 들지 않았다. 단지 시험 상황에서 감독과 채점에 예외적인 상황을 일으키고 싶지 않을 뿐 아니라, 언제 터질지 모르는 버그의 위험을 안고 시험을 치르고 싶지 않았다.</p>\n\n<p>드물게 일반적인 상황에서 프리징이 발생하거나 열려야할 프로그램이 재부팅하기 전까지 열리지 않고는 했다. 게다가 거의 항상 부팅 후 바탕화면이 나타나기까지 15초에서 30초까지 걸리고는 했다. 메인보드가 제대로 호환되지 않거나 그놈 환경을 불러오는데 오류가 발생하는 것 같다. 시험 중에 언제 어떻게 컴퓨터를 재부팅 할 상황이 발생할지 모르는데 이렇게 불안정한 부팅 환경 속에서 시험을 치를 수는 없었다. 한 마디로, 신뢰하기 어렵다.</p>\n\n<h2 id=\"백업이-어렵다\">백업이 어렵다</h2>\n\n<p>조금은 개인적인 이유다. 나는 백업을 이중, 삼중으로 철저하게 하는 편이다. 그 과정에서 라즈베리파이로 만든 NAS와 기타 저장장치들을 쓴다. 가장 중요한 데이터들이 저장된 맥은 타임머신으로 나스에 실시간 백업을 하고 있다. 윈도우는 높은 성능을 요구하는 프로그램(이번 프로젝트 과제가 그런 종류였다)을 돌리는데 쓴다. 이런 프로그램들은 맥에서 작업하고 깃헙에 올리기 때문에 윈도우에서 따로 백업을 할 이유는 없다. 그 외에 NAS에 있는 대용량 파일을 다루는 작업이나 게임하는데 윈도우를 사용하기 때문에 굳이 윈도우 환경을 백업하지는 않고 있다. 그럴 공간도 없고.</p>\n\n<p>리눅스 민트에서 했던 일들은 중요한 것들이었다. 환경에 빨리 익숙해지고 싶고, 더 가벼운 Vim같은 에디터를 쓰기 위해 리눅스에서 과제 몇 개를 진행했다. 코드들은 깃헙에 백업할 수 있었지만 코드들을 포함해 리눅스 환경의 설정들과 에디터의 설정들도 어딘가에 백업하고 싶었다. 리눅스 민트는 TimeShift 라는 백업 솔루션을 제공한다. 타임쉬프트를 사용하면 연결된 저장장치 중 하나에 현재 운영체제의 모든, 아니면 원하는 파일들을 백업할 수 있다. rsync를 사용한 백업인데, 맥의 타임머신이나 윈도우의 백업과 같이 정해진 시간마다 파일들을 스냅샷으로 백업하고 원하는 개수의 백업만 유지할 수 있다.</p>\n\n<p>하지만 내가 느꼈던 불편함은 다름아닌 NAS와의 궁합이었다. NAS를 외장 하드와 같은 위치에 마운트 했음에도 타임쉬프트는 이를 잡지 못했다. 오직 USB 메모리나 외장 하드만 인식할 뿐이었다. 노트북에서 뜯어낸 SSD가 하나 있었지만 128기가나 되는 용량의 SSD를 고작 40기가 남짓되는 리눅스 환경의 백업을 위해 쓰는 것은 너무 비효율적이라고 생각했다. 같은 용량의 USB 메모리는 쓰기속도가 너무나도 느려서 모두 백업하는데 7시간이 넘게 걸려서 포기했다. NAS에 백업을 할 수 없다는 것은 주 작업 환경으로 쓰든데 있어 치명적인 단점이었다.</p>\n\n<h2 id=\"클라우드-서비스를-쓰기-어렵다\">클라우드 서비스를 쓰기 어렵다</h2>\n\n<p>사실 위의 문제는 저장 장치 종류에 달린 문제였다. 돈을 더 쓴다면, 위험을 더 감수한다면 굳이 경험하지 않아도 될 문제라는 것이다. 그래서 내가 동시에 백업 방법으로 사용하는 클라우드 서비스를 이용해 봤다. 대학생 혜택으로 오피스 365를 무료로 구독중이고 여기에는 원드라이브 1테라도 포함되어있다. 내 모든 대학 관련 자료들은 여기에 1차적으로 저장하고 2차적으로 NAS에 아카이브한다. 이 원드라이브를 리눅스 민트에서 쓸 수 있다면 NAS에는 일일이 옮겨야 하겠지만 그래도 나름 파일 백업의 안정성은 확보할 수 있었다.</p>\n\n<p><a href=\"https://github.com/abraunegg/onedrive\">리눅스에서 원드라이브를 사용하는 방법</a>은 그렇게 어렵지 않다. 단지 아주 치명적인 단점을 감수하기만 하면 된다. 일단 실시간 동기화가 지원되지 않는다. 그리고 무엇보다, 필요할 때만 파일을 다운로드할 수가 없다. 동기화시에 모든 파일을 다운로드하고 모든 파일을 업로드한다. 내 원드라이브는 거의 대부분 문서와 사진들이 저장되어 있기 때문에 30기가를 넘지 않는다. 1테라의 전체 용량에 비하면 작지만 리눅스 민트가 설치된 128기가 SSD에 모두 저장하기에는 꽤 부담스럽다. 현재 설치된 50기가에 20기가 원드라이브 파일들까지 합치면 남은 용량이 얼마 없게 되는 것이다.</p>\n\n<p>원드라이브 웹 페이지를 일일이 방분하면서 파일들을 손수 동기화 할 수도 있지만, 파일의 파편화와 버전 관리의 불편함 떄문에 도저히 이런 방법을 쓸 엄두가 나지 않았다.</p>\n\n<h2 id=\"결론\">결론</h2>\n\n<p>컴퓨터 역사에 빼놓을 수 없는 운영체제인 리눅스를 써보지도 않는 것은 불가능하다고 생각한다. GCC를 포함한 첨파일 환경을 구성해본다거나, vim으로 설정파일을 만지작거리거나, 여러 패키지들을 설치해보는 경험들을 통해 리눅스, 더 나아가 운영체제가 어떻게 구성되고 돌아가는지 배우는 것은 중요하고 나름 재미있다.</p>\n\n<p>하지만 교육이나 특수한 목적이 아닌 장기적이고 범용적인 실 사용에 있어서 리눅스는 그리 썩 편안하지 못하다. 윈도우처럼 PC시장의 표준으로 군림하며 하드웨어 제조사가 아예 처음부터 윈도우를 고려하고 만들게 하거나 맥처럼 철저히 폐쇄적으로 하드웨어 몇 개만 지원하는 것이 아닌 까닭으로, 리눅스는 내 입장에서 항상 불안한 운영체제다.</p>\n\n<p>내가 SMB나 FTP만 사용하여 파일을 주고받는 서버 역할의 컴퓨터를 구성한다면 고민도 없이 데비안 기반 OS를 설치할 것이다. 친구들끼리 접속하는 작은 게임 서버를 만든다면 이 역시 우분투나 아치를 선택할 것이다. 왜냐하면 그것들은 아주 적은 몇 가지 일들만 ‘잘’하면 되기 때문이다. 하지만 만약 ‘아주 많은 종류’의 일들을 성능은 그럭저럭일지 몰라도 ‘확실하게’ 해야 한다면 리눅스 진영의 OS를 선택하고 싶지 않다.</p>\n\n<p>간간히 성능 비교 등을 위해 다른 환경이 필요할 때나 리눅스 민트를 켤 것 같다. 온전히 리눅스 민트만 쓰기에는 윈도우와 맥에 너무나 많은 편리함이 존재한다.</p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/extra/","name":"2021-06-02-Linux_mint_review_2.md","path":"post/extra/2021-06-02-Linux_mint_review_2.md","url":"/post/extra/2021-06-02-Linux_mint_review_2.html"},{"sort":1,"title":"라즈베리파이에 관한 이야기","date":"2021-02-27 17:07:53 +0900","categories":["라즈베리파이"],"layout":"default","content":"<h2 id=\"1-컴퓨터\">1. 컴퓨터</h2>\n\n<p>시간이 흐르면서 컴퓨터의 성능은 비약적으로 발전했다. 때문에 비록 라즈베리파이가 평소 우리가 자주 접하는 컴퓨터의 성능에 턱없이 모자른 성능으로 보일지 모르지만 삼사십년 전에 라즈베리파이 만한 성능의 컴퓨터는 몇 백만원을 호가했다. 심지어 더욱 거슬러 올라간다면 집채만했던 컴퓨터가 지금 내 손바닥에 올라와 있는 라즈베리파이보다 성능이 안좋았던 시절도 있었다. 그 당시 대부분의 컴퓨터는 너무나 성능이 좋지 않아 지금 쓰는 고수준 프로그래밍 언어(그래봤자 현대에는 저수준이라고 까이는 C 같은 언어들)로 프로그램을 작성 할 수도 없었다. 더욱 하드웨어 친화적인, 따라서 더욱 컴퓨터의 부담이 적은 어셈블리어나 기계어로 작성했다.</p>\n\n<p>그런 컴퓨터를 싣고 아폴로 11호는 달에 착륙했으며, 우주비행사가 내린 명령을 다른 계산을 하는 도중에 실시간으로 판단하여 위험한 명령이면 다시 생각해보라고 알리기까지 했다. 우주왕복선의 컴퓨터는 더욱 발전하여 우주비행사가 해야 할 일은 고작 착륙할 때 필요한 바퀴를 내리는 버튼을 누르는 일 뿐이었다. 이조차 우주비행사의 심리적인 책임감을 위해 남겨뒀을뿐 안전과 효율을 고려한다면 오히려 컴퓨터가 처음부터 끝까지 모든 일을 하는 것이 더 나은 일이었다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520639-97108400-d6ec-11eb-90c4-257bb0a9cfec.jpeg\" /></p>\n\n<p>분명 지금 있다면 윈도우조차 설치되지 않을 성능의 컴퓨터들이지만 분명 다양하고 때론 중요한 일을 했던 컴퓨터들이 있었다. 컴퓨터를 단지 게임기나 문서 편집기 이상의 무언가로 생각하는 사람들이라면 컴퓨터에 얼마나 가파른 성능 향상이 있었는지, 그리고 그에 따라 우리가 얼마나 더 많은 일들을 컴퓨터로 해낼 수 있게 되었는지, 그럼에도 불구하고 우리가 컴퓨터에게 얼마나 간단한 일을 시키느라 그 성능을 낭비하고 있는지 깨닫는다면 분명 짜릿한 전율을 느낄 것이다.</p>\n\n<p>그리고 그런 사람들은 생각한다. 우리가 단지 성능에 관해서 사치를 부리지만 않는다면. 정말 딱 필요한 정도의 성능을 가진 컴퓨터를 만든다면 어떻게 될까? 라즈베리파이는 그런 사람들에게 주어진 선물같은 도구다.</p>\n\n<h2 id=\"2-라즈베리파이란\">2. 라즈베리파이란?</h2>\n\n<p>라즈베리파이의 역사나 자잘한 성능표를 읊고 싶지는 않다. 중요한 것은 인터넷, 서버, 운영체제 등 컴퓨터와 관련된 많은 것들을 배우는 것에 그치지 않고 특정 용도로 지속적으로 사용하는데에도 부족함이 없다는 것이다. 보통의 데스크탑처럼 웹서핑이나 문서작업에 쓸 수도 있다. 운영체제를 마이크로SD 카드에 저장하기 때문에 입출력이 조금 느릴 수는 있으나 뭐 어떠랴. 4K모니터를 두개나 달 수도 있는데. MATLAB을 굴리거나 저사양이지만 마인크래프트를 돌릴 수도 있다. 파이썬, C, 스크래치 같은 프로그래밍 언어로 프로젝트를 할 수도 있다. GPIO에 아누이노나 센서들을 연결해 수 없이 많은 감지기들을 만들 수도 있으며, 카메라를 달아 얼굴 인식 프로그램을 만들어 사람을 볼때마다 인사를 하게 할 수도 있다. 아니면 필자처럼 무난하게 NAS나 블로그 서버를 돌릴 수도 있다. 정말 말 그대로 현대 컴퓨터가 하는 일은 뭐든 할 수 있다.</p>\n\n<p>그러나 우리 마음에 가장 와닫는 것은 바로 그것의 가격이다. 모델의 종류마다 다르지만 가장 싼 라즈베리파이는 5달러이며 가장 사양이 높은 최신 모델은 75달러까지 있다. 일반 사용자용 컴퓨터 못지않은 굉장한 범용성을 갖춘 컴퓨터가 고작 몇 만 원이라니, 얼마나 놀라운 일인가? 몇 십 년 전만 해도 몇 백은 줘야 얻을 수 있었던 성능의 컴퓨팅 성능을 우리는 단돈 오 만원에 손에 쥘 수 있게 된 것이다. 말 그대로 손에!</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520640-97108400-d6ec-11eb-88e3-b2bcf4e843ad.png\" /></p>\n\n<p>필자가 라즈베리파이를 구매하고 사용한 지난 몇 달은 “아니 이게 돼?”의 연속이었다. 이 글에서는 라즈베리파이가 얼마나 넓은 범용성을 가지고 있는지, 그게 얼마나 놀라운 일인지 간략하게 소개할 것이다.</p>\n\n<h2 id=\"3-내-라즈베리파이\">3. 내 라즈베리파이</h2>\n\n<p>라즈베리파이 4B+에 개인용 NAS와 <a href=\"https://altair823.com\">블로그</a> 서버를 올려 사용중이다. 트랜스미션을 설치해서 밤새 토렌트 파일을 받아놓기도 한다. 이걸로 많은 프로젝트를 했지만 계속 유지할만한 것들은 위에 세 개 정도였다.</p>\n\n<h3 id=\"1-nas\">1) NAS</h3>\n\n<p>처음 나스를 구성하게 된 이유는 군대 때문이었다. 군 복무를 하며 프로그래밍 프로젝트를 할 시간이 생겼다. 비록 짧은 시간들이었지만 그래도 코드들을 백업할 필요성을 느꼈다. 깃허브에 커밋하거나 드롭박스에 파일 채로 업로드하는 방법도 있었고 실제로도 그렇게 했다. 그러다가 나스를 알게되었고 또한 나스를 구성하는 가장 저렴한 방법이 라즈베리파이라는 것도 알게되었다. 후에 여러가지로 활용도 할 수 있고 가장 중요한 나스로 사용할 수 있었다. 휴가에 맞춰 주문하여 받았다. OMV를 설치하여 나스로 사용하였고 현재까지도 굉장히 만족하며 사용중이다.</p>\n\n<p>파일의 백업과 저장공간의 확장은 단지 외장 저장장치를 사용하면 된다. 어떤 면에서는 더 이해하기 쉽고 편할 수도 있다. 나도 외장 HDD와 나스 사이에서 수없이 고민했던 기억이 있다. 시놀로지나 아수스토어와 같은 비싼 기성품 나스를 사용하지는 않았기에 가성비 측면은 크게 차이가 없었지만 안정적인 사용과 높은 수준의 보안을 위해서는 외장 하드가 더 나은 선택이었다. 인터넷이 끊어지면 사용 불가능한 나스와 달리 외장하드는 케이블이 연결되어 있다면 언제나 연결과 속도를 보장한다. 게다가 외부 인터넷에 연결하여 사용하는 나스의 특성상 파일 보안의 측면에서 분명 안심할 수 없는 부분이 있다. 조금 불편하긴 할테지만 어느 정도 이동성도 갖추고 있었기 때문에 밖에서도 파일에 접근 할 수 있다는 나스의 장점도 일부 희석되었다.</p>\n\n<p>그런 많은 고민에도 불구하고 나는 나스를 선택했다. 가장 직접적인 이유는 내가 윈도우와 맥을 번갈아가며, 때로는 동시에 사용한다는 사실이다. 따라서 윈도우의 NTFS포멧이나 애플에 APFS포멧에 구애받지 않고 두 운영체제 모두에서 접근가능한 장치가 필요했다. 물론 특정 프로그램을 설치하고 EXT4나 NTFS 그대로 사용하더라도 가능했겠지만 포트가 부족한 맥북이나 아예 포트가 존재하지 않는 아이폰까지 생각하면 외장하드는 백업 용도로만 사용할 수 밖에 없는 반쪽짜리 저장장치였다.</p>\n\n<p>당시 내가 군인 신분이었던 것도 한 몫했다. 부대에서 작성한 코드들을 백업하려면 외장 하드를 부대 안으로 반입해야하지만 규정상 어려운 일이었다. 모든 부대원들이 공용으로 사용하는 컴퓨터에 내인 하드를 꽂는 것도 썩 내키는 일이 아니었다. 그랬기 때문에 더욱 인터넷으로 접근 가능한 저장 공간이 필요했으며 라즈베리파이로 만든 나스는 그 필요를 충족할 뿐만 아니라 앞으로 진행할지도 모르는 많은 프로젝트들을 생각했을 때 최고의 선택이었다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520641-97a91a80-d6ec-11eb-8a90-a7cf1a2fb47f.jpg\" /></p>\n\n<p>몇 번의 시행착오 끝에 완성하여 지금까지 알차게 사용하고 있는 나스는 하드를 두 개 달아 하나는 맥북 타임머신 백업용으로, 하나는 윈도우와 맥에 있는 프로젝트 백업과 입출력이 상대적으로 느려도 별로 상관없는 대용량 파일을 저장하는데 쓰고 있다. 실시간 영상 편집과 같은 대용량 파일의 높은 입출력 속도를 요구하는 작업이 아니라면 개인의 일반적인 업무에는 정말 차고 넘치는 성능을 제공한다.</p>\n\n<p>개인적으로는 미니 ITX 컴퓨터로 바꾸고 나서는 3.5인치 하드를 컴퓨터에 설치할 수 없어서 난감했는데 그때 남은 하드를 알차게 활용할 수 있어서 만족하는 중이다.</p>\n\n<h3 id=\"2-블로그-서버\">2) 블로그 서버</h3>\n\n<p>아파치2와 php, 워드프레스를 라즈베리파이에 올려서 블로그 서버로 사용 중이다. 자세한 방법이나 내가 겪었던 시행착오는 나중에 따로 쓰기로 하고 이번에는 소감만 간단히 말한다.</p>\n\n<p>첫 번째로 느낀 것은 모든 것이 완성되어 정상적으로 돌아갈 수 있기까지 비록 겉핥기 수준이지만 내가 정말 많은 것을 배웠다는 것이다. 짧은 지식이라 굳이 배운 것을 자랑하고 싶지는 않지만 완성하기 전의 나와 후의 나는 분명 다르다고 자신한다. 외부에서 페이지에 접속할 수 있도록 하는 것부터 구글에서 구매한 도메인에 사이트를 연결하여 주소창에 도메인을 쳐 접속할 수 있도록 하는 것까지, 일어난 문제를 해결해 갈 때마다 짜릿한 성취감과 더불어 그 부분에 대한 나름 깊은 이해와 통찰을 얻을 수 있었다. 블로그의 내용과는 별개로 목표로 하던 것을 많은 시행착오를 거쳐 결국 완성시켰다는 사실이 내게 정말 큰 기쁨을 주었다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520642-9841b100-d6ec-11eb-8193-56a5072dbab2.png\" /></p>\n\n<p>하지만 치명적인 오류를 마주할 때마다 왜 사람들이 이런 설치형 개인 블로그를 사용하지 않고 네이버나 티스토리에서 운영하는 서비스형 블로그를 사용하는지 뼈저리게 알게되었다. 만약 내가 블로그의 완성과 운영이 목표가 아니라 그 안에 담을 내용을 생각했고 서버의 안정성을 원했다면 절대 라즈베리파이에 설치하는 방식을 선택하지 않았을 것이다. 서버는 불안정하고, 부족한 기능을 추가하고 유지보수하는 과정에서 정작 블로그에 담을 내용에는 집중하지 못하는 경우가 생긴다.</p>\n\n<p>페이지에 글을 남길 수 있도록 하는데까지 이틀은 족히 걸렸고, 구글 검색에 뜨게 하는데까지 나흘이 걸렸다. 그럼에도 불구하고 아직 작동하지 않는 많은 기능들이 나를 불편하게 한다. 이런 상황속에서 글을 쓰는 일에 집중하는 것은 불가능한 것 같다. 짧은 내 지식으로는 이런 종류의 서버를 완벽하게 만들지 못하는 바, 정말 질 좋은 글들을 쓰는데 집중하려면 차라리 다른 서비스형 블로그를 이용할 것이라는 결론에 도달했다. 정말로 내 목표가 사이트의 완성이 아니었다면 티스토리에 블로그를 만들었거나 아예 만들지 않았을 것이다.</p>\n\n<h3 id=\"3-트랜스미션\">3) 트랜스미션</h3>\n\n<p>트랜스미션은 토렌트 파일을 다운받는 프로그램이다. 가끔 용량이 무지막지한 토렌트 파일을 받아야 할 때가 있었다. 가는 명주실 같은 다운 속도를 보여주는 파일도 있다. 낮에는 도대체가 다운이 안되다가 새벽이 되어서야 피어가 나타나 다운이 시작되는 경우도 있었다. 쓸데없이 컴퓨터 리소스를 차지하여 게임이나 인터넷을 느리게 만든다. 25ms에서 놀던 핑이 단숨이 300ms으로 튀기도 한다. 단지 호기심에 설치해봤지만 지금 와서는 나름 만족하며 사용중인 기능이 되었다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520643-9841b100-d6ec-11eb-839d-fefe952d60bc.png\" /></p>\n\n<h2 id=\"4-결론\">4. 결론</h2>\n\n<p>라즈베리파이의 매력은 결핍이라고 생각한다. 분명 우리 책상 위에는 놀라운 성능의 컴퓨터가 올려져 있다. 게임도 신나게 돌리면서 유튜브도 동시에 켜 놓을 수 있다. 2021년 초 지금 개인 컴퓨터 시장은 놀라운 변화를 맞이하고 있다. 메인스트림 PC는 4코어에서 6코어로 훌쩍 뛰었고, AMD는 드디어 게이밍 성능에서조차 인텔을 따라잡으며 다시금 과거의 영광을 되찾으려 하고 있다.  엔비디아는 일반 사용자용으로서는 전례없는 성능향상을 이룬 신세대 그래픽카드를 출시했다. 이런 컴퓨터들로 무언가를 못한다는 것은 상상하기 어렵다.</p>\n\n<p>하지만 라즈베리파이는 ‘고작 이게?’라는 놀라움을 끊임없이 일으킨다. 핸드폰 충전기에 연결된 손바닥만한 초록 기판의 부족한 성능을 짜내어 프로젝트를 진행하다보면 정말 컴퓨터가 무엇인지 놀랍도록 빠르게 배울 수 있을 것이다.</p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/raspberrypi/","name":"2021-02-27-first.md","path":"post/raspberrypi/2021-02-27-first.md","url":"/post/raspberrypi/2021-02-27-first.html"},{"sort":1,"permalink":"/post/","layout":"default","title":"컴퓨터","content":"<h1 id=\"컴퓨터\">컴퓨터</h1>\n\n<ul>\n <li><a href=\"/post/data_structure/\">자료구조</a>\n <ul>\n <li><a href=\"/post/data_structure/2021-04-27-qsort.html\">qsort.c 분석</a></li>\n <li><a href=\"/post/data_structure/2021-05-10-Linked_list_searching_with_index.html\">연결리스트에서 탐색 빠르게 하기</a></li>\n <li><a href=\"/post/data_structure/2021-06-26-Tree.html\">AVL과 RB비교</a></li>\n <li><a href=\"/post/data_structure/2021-07-13-maze_structure.html\">미로의 자료구조</a></li>\n </ul>\n </li>\n <li><a href=\"/post/algorithm/\">알고리즘</a>\n <ul>\n <li><a href=\"/post/algorithm/2021-07-13-Eller's_algorithm.html\">미로 생성 알고리즘</a></li>\n </ul>\n </li>\n <li><a href=\"/post/raspberrypi/\">라즈베리파이</a>\n <ul>\n <li><a href=\"/post/raspberrypi/2021-02-27-first.html\">라즈베리파이에 관한 이야기</a></li>\n <li><a href=\"/post/raspberrypi/2021-02-27-madeNAS.html\">라즈베리파이에 OMV로 NAS만들기</a></li>\n <li><a href=\"/post/raspberrypi/2021-03-02-transmission_error.html\">트랜스미션 “Permission denied…” 오류 해결하기</a></li>\n <li><a href=\"/post/raspberrypi/2021-03-02-OMV(1).html\">OMV를 사용하며 겪었던 시행착오들 (1)</a></li>\n <li><a href=\"/post/raspberrypi/2021-03-02-OMV(2).html\">OMV를 사용하며 겪었던 시행착오들 (2)</a></li>\n </ul>\n </li>\n <li><a href=\"/post/extra/\">기타</a>\n <ul>\n <li><a href=\"/post/extra/2021-06-02-Linux_mint_review_1.html\">리눅스 민트 설치 후기 1</a></li>\n <li><a href=\"/post/extra/2021-06-02-Linux_mint_review_2.html\">리눅스 민트 설치 후기 2</a></li>\n </ul>\n </li>\n <li><a href=\"/post/Python/\">파이썬</a>\n <ul>\n <li><a href=\"/post/Python/2021-06-30-Project_Word_Finder_1.html\">Word Finder 개발기 1</a></li>\n <li><a href=\"/post/Python/2021-07-05-Project_Word_Finder_2.html\">Word Finder 개발기 2</a></li>\n <li><a href=\"/post/Python/2021-07-05-Project_Word_Finder_3.html\">Word Finder 개발기 3</a></li>\n </ul>\n </li>\n</ul>\n","dir":"/post/","name":"README.md","path":"post/README.md","url":"/post/"},{"sort":1,"permalink":"/post/data_structure/","layout":"default","title":"자료구조","content":"<h1 id=\"자료구조\">자료구조</h1>\n\n<ul>\n <li><a href=\"/post/data_structure/2021-04-27-qsort.html\">qsort.c 분석</a></li>\n <li><a href=\"/post/data_structure/2021-05-10-Linked_list_searching_with_index.html\">연결리스트에서 탐색 빠르게 하기</a></li>\n <li><a href=\"/post/data_structure/2021-06-26-Tree.html\">AVL과 RB비교</a></li>\n <li><a href=\"/post/data_structure/2021-07-13-maze_structure.html\">미로의 자료구조</a></li>\n</ul>\n","dir":"/post/data_structure/","name":"README.md","path":"post/data_structure/README.md","url":"/post/data_structure/"},{"sort":2,"permalink":"/post/algorithm/","layout":"default","title":"알고리즘","content":"<h1 id=\"알고리즘\">알고리즘</h1>\n\n<ul>\n <li><a href=\"/post/algorithm/2021-07-13-Eller's_algorithm.html\">미로 생성 알고리즘</a></li>\n</ul>\n","dir":"/post/algorithm/","name":"README.md","path":"post/algorithm/README.md","url":"/post/algorithm/"},{"sort":2,"title":"라즈베리파이에 OMV로 NAS만들기","date":"2021-02-27 10:56:01 +0900","author":"altair823","categories":["NAS"],"layout":"default","content":"<h2 id=\"1-omvopenmediavault의-이해\">1. OMV(OpenMediaVault)의 이해</h2>\n\n<p>라즈베리파이는 강력한 컴퓨터다. 물론 우리가 맨 처음 떠올리는 컴퓨터의 이미지에는 미치지 못하지만 어떤 일들은 다른 강력한 컴퓨터보다 더 효율적으로 수행할 수 있다. 라즈베리파이의 기본적인 정보는 다른 글에서 다루기로 하고 이번 글에서는 라즈베리파이에 OMV(OpenMediaVault)로 NAS를 만드는 법을 다루겠다.</p>\n\n<p>OMV는 라즈베리파이를 포함한 다양한 컴퓨터를 NAS로 사용할 수 있도록 해주는 프로그램이다. 오드로이드나 라떼판다와 같은 싱글보드 컴퓨터들도 충분히, 어쩌면 더욱 강력한 성능의 NAS로서 기능할 수 있다. 그러나 라즈베리파이 만큼 다양한 기능을 제공하고 많은 레퍼런스가 존재하는 싱글보드 컴퓨터는 아직 존재하지 않는다. 따라서 전문적인 용도가 아니라면 (때로는 전문적인 용도로도) 충분히 강력하다.</p>\n\n<p>이 글에서 OMV의 자잘한 설정은 다루지 않는다. 가장 기본적이고 중요한 설정만 다룰 예정이다.</p>\n\n<h2 id=\"2-omv설치\">2. OMV설치</h2>\n\n<p>뭐든 가장 정확하고 깔끔하게 설치하는 법은 공식 홈페이지에서 제공하는 설명을 읽는 것이다. 아래는 OMV 공식 홈페이지의 설치 메뉴얼이다.</p>\n\n<p><a href=\"https://wiki.omv-extras.org/doku.php?id=installing_omv5_raspberry_pi\">https://wiki.omv-extras.org/doku.php?id=installing_omv5_raspberry_pi</a></p>\n\n<p>OMV4까지는 특정 이미지를 직접 sd카드에 플래시 할 수 있었으나 어차피 같은 데비안 리눅스 기반으로 터미널에서 설치 할 수 있는 패키지라 현재는 이미지를 제공하지 않는다. 따라서 콘솔로 설치해야 한다.</p>\n\n<p>기본적으로 준비해야 할 것들이 있다. 유선으로 인터넷에 연결된 라즈베리파이와 라즈베리파이 운영체제인 라즈비안이 설치된 마이크로 sd카드가 필요하다. 자질구레한 설정과 플러그인을 설치해도 4기가를 넘지 않으나 개인적으로는 16기가 마이크로 sd카드가 제일 가성비 좋다고 생각한다.</p>\n\n<p>라즈베리파이와 ssh연결을 수립하는 것은 다루지 않겠다. 라즈베리파이의 최신화를 끝냈다면 터미널에 다음을 입력한다.</p>\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\" data-enlighter-theme=\"godzilla\">wget -O - https://github.com/OpenMediaVault-Plugin-Developers/installScript/raw/master/install | sudo bash</pre>  \n\n<p>오랜 시간이 걸리고 라즈베리파이가 재부팅 될 것이다. 그동안 절대 ssh 터미널화면을 끄지 않길 바란다. 이는 설치과정을 강제로 중단시킨다. 이후 라즈베리파이의 IP주소로 접속하면 OMV5의 웹 화면이 나온다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520558-46009000-d6ec-11eb-81b2-0187ba99efe2.png\" /></p>\n\n<p>기본 아이디와 패스워드는 admin과 openmediavault이다. 입력하여 접속하면 다음과 같은 화면이 나온다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520562-4862ea00-d6ec-11eb-855f-3767cb1154e5.png\" /></p>\n\n<p>필자는 이미 필요한 세팅을 끝냈기 때문에 FTP와 SMB에 초록불이 들어와있다. 하지만 맨 처음 설치한 사람이라면 불이 들어와있지 않을 것이다. 가장 먼저 해야할 것은 관리자 계정의 비밀번호를 바꾸는 것이다. 좌측 메뉴에 일반 설정에서 웹 관리자 암호 탭을 선택한다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520564-49941700-d6ec-11eb-8da2-5a3af892fb20.png\" /></p>\n\n<p>보안을 위해 반드시 새로운 암호로 변경하는 것이 좋다.</p>\n\n<h2 id=\"3-저장장치-설정\">3. 저장장치 설정</h2>\n\n<p>이후 필요한 저장 장치를 라즈베리파이에 연결한다. 필자는 4테라 하드와 1테라 하드를 하드 도킹 스테이션에 USB 3.0으로 연결해 사용중이다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520565-4ac54400-d6ec-11eb-9eab-f3e130d8e844.jpg\" /></p>\n\n<p>장치를 연결했다면 왼쪽 사이드바에서 디스크를 클릭한다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520567-4b5dda80-d6ec-11eb-9b50-c263980187da.png\" /></p>\n\n<p>필자는 하드 두개와 2.5인치 SSD하나, 128기가 USB를 사용하고 있다. 위에서부터 씨게이트 하드, 샌디스크 SSD, 웨스턴 디지털 하드, 샌디스크 USB가 인식된 상태다. 만약 아무것도 연결하지 않았거나 어떤 이유로 인식이 불가능하다면 마이크로 SD카드만 보일 것이다. 정상적으로 인식되었다면 해당 장치가 저 리스트 중에 있을 것이다.</p>\n\n<p>OMV는 많은 종류의 파일 시스템을 인식할 수 있다. 거기엔 윈도우의 NTFS와 리눅스의 EXT4, ZFS 같은 것들도 포함된다. 해당 파일 시스템이라면 분명 어느 부분 그대로 사용 가능하지만 이에대한 내용은 다른 글에 소개하겠다.</p>\n\n<p>OMV의 웹 페이지에서 변경된 설정이 감지되면 이를 적용할 것인지 물어보는 알림이 위에 뜬다. 안정성을 위해 해당 알림이 뜬다면 바로바로 변경사항을 적용하기 바란다.</p>\n\n<p>맨 처음 장치를 연결했다면 지우기를 눌러 장치의 모든 내용을 삭제한다. 마이크로 SD카드는 절대 건드리지 않는다. 완료되었다면 사이드 바에 파일 시스템을 클릭한다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520568-4bf67100-d6ec-11eb-9f64-a0a503fa95b2.png\" /></p>\n\n<p>필자는 이미 파일 시스템들이 존재한다. 이중 boot와 rootfs는 라즈베리파이의 SD카드에 만들어진 파일들이니 이미 존재할 것이고 절대 건드리지 않는다. 전 단계에서 지우기를 눌렀다면 이 두 개 외에는 어떤 파일 시스템도 존재하지 않을 것이다. 왼쪽 위에 생성을 눌러 파일 시스템을 생성한다.<img src=\"https://user-images.githubusercontent.com/46125008/123520572-4d279e00-d6ec-11eb-92d1-be990a4a5e43.png\" /></p>\n\n<p>장치를 선택하고 레이블을 입력한다. 파일 시스템의 포맷은 BTRFS와 EXT4중에 하나를 고르는 것이 마음 편하다. 나머지 파일 시스템은 너무 오래되었거나, 모바일에 최적화되어 있거나, 일반사용자에게는 의미없는 기능을 위해 만들어진 것이다. 필자는 모든 하드를 EXT4로 포맷하여 사용중이며 충분히 안정적인 성능을 보여주고 있다.</p>\n\n<p>파일 시스템을 생성했다면 이제 정상적으로 OMV에서 장치로 접근 가능하다는 것이다. 이 부분에서 라즈베리파이에 자동으로 마운트 되는데, GUI를 포함한 라즈비안을 설치한 사람은 라즈베리파이 바탕화면에서 해당 장치를 찾을 수 없어서 의아할 것이다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520574-4d279e00-d6ec-11eb-9faf-c4440cd96cd2.png\" /></p>\n\n<p>장치는 /srv 경로에 존재한다. 과거에는 레이블을 사용하여 폴더를 생성했지만 지금은 UUID를 폴더명으로 사용한다.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>/srv/dev-disk-by-uuid-03c2bd42-99e7-449f-85cc-************\n</code></pre>  </div></div>\n\n<p>이런 형식으로 폴더가 생성되어 있을 것이다. 트랜스미션의 설정과 같은 이유로 필요하다면 해당 파일 시스템의 UUID를 알아놓기 바란다.</p>\n\n<p>다시 OMV웹 페이지로 돌아간다. 사이드바에서 사용자를 클릭한다. OMV의 모든 폴더는 PI계정을 제외하면 권한을 준 사용자만 접근이 가능하며 반드시 필요한 상황이 아니라면 관리자 계정이 아닌 특정 사용자를 따로 생성하여 접근하는 것이 보안상 필요하다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520576-4dc03480-d6ec-11eb-93d9-1f5e38f54f84.png\" /></p>\n\n<p>왼쪽 위에 추가를 눌러 사용자를 추가하자. 필요한 경우가 아니라면 그룹이나 공개 키는 따로 수정하지 않아도 될 것이다.</p>\n\n<p>사용자를 추가했다면 다시 사이드바에서 공유폴더를 선택한다.</p>\n\n<p>이 또한 추가를 눌러 필요한 정보를 입력해준다. 파일 시스템의 레이블과 공유폴더의 이름은 같을 필요 없다. 하나의 파일시스템에 용도에 따라 여러개의 공유폴더가 존재해도 된다. 공유폴더 이름과 공유폴더가 존재할 장치를 선택하고 저장한다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520629-8fe97600-d6ec-11eb-9ab6-f09abcce134d.png\" /></p>\n\n<p>필자는 이미 두개의 공유폴더를 사용중이다. 만약 공유폴더를 생성했다면 위 그림처럼 새로운 공유폴더가 보일 것이다. 이를 선택하고 위에 권한을 누른다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520631-911aa300-d6ec-11eb-8e12-546ba0204275.png\" /></p>\n\n<p>필자의 공유폴더에 설정된 권한이다. 맨 위에 아이디는 필자가 쓰는 계정, 그 아래는 테스트용으로 생성한 계정이다. 그 밑에 두개는 기본으로 생성되는 관리자 계정이다. 관리자계정와 자신이 사용할 계정의 읽기/쓰기 권한을 부여하고 저장한다.</p>\n\n<p>여기까지 문제없이 성공했다면 이제 파일을 저장할 폴더가 만들어졌고 이를 저장할 수 있는 권한이 있는 계정까지 만들어졌다. 하지만 우리는 이 폴더에 접근할 수 없는데 이는 우리가 다른 컴퓨터에서 라즈베리파이 내부에 존재하는 해당 폴더에 접근할 방법이 없기 때문이다. 물론 SSH와 같은 방법이 있기는 하나, 대용량이거나 많은 개수의 파일을 폴더에 저장하거나 폴더에서 꺼내기에 적합한 방식이 아니다.</p>\n\n<h2 id=\"4-ftp-smb설정\">4. FTP, SMB설정</h2>\n\n<p>가장 편리한 방법으로 FTP와 SMB를 들 수 있는데 여기서는 이 둘만 다루기로 한다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520632-91b33980-d6ec-11eb-9eb1-18a0697c2fab.png\" /></p>\n\n<p>사이드바에서 FTP를 선택한다. 특별한 보안상 위험을 걱정하지 않는다면 필자와 같은 세팅을 해도 무방하다고 본다. 높은 보안 수준을 걱정해야 할 파일이라면 이런 곳에 저장하지 않거나 이미 이 설정에 대한 이해가 충분할 것이다. 보안보다는 연결의 수월함이 중요한 필자는 위 사진처럼 설정을 하였다. 이후 공유탭을 선택한다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520634-94ae2a00-d6ec-11eb-9a0c-6e6ad3c65097.png\" /></p>\n\n<p>필자의 두 공유폴더가 보인다. 처음 설정하는 사람이라면 여기에 공유폴더가 보이지 않을 것이다. 추가를 누르자.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520635-94ae2a00-d6ec-11eb-910f-f7fdea2e8204.png\" /></p>\n\n<p>공유 폴더를 선택하고 저장하자.</p>\n\n<p>여기까지 완료했다면 이제 공유폴더에 FTP로 접근할 수 있게 된 것이다. Filezilla와 같은 FTP파일 전송 프로그램을 이용하여 폴더에 접근해보자.</p>\n\n<p>이제 SMB를 설정하기 위해 사이드바에서 SMB를 선택하자.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520636-9546c080-d6ec-11eb-964a-27a9e001eadb.png\" /></p>\n\n<p>활성화 버튼 외에는 건드릴 것이 없다. 활성화 시켜주고 저장하자. 그리고 공유탭으로 들어간다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520637-95df5700-d6ec-11eb-8439-7f401fb14047.png\" /></p>\n\n<p>필자의 공유폴더 두 개가 보인다. 처음 설정한다면 아무것도 보이지 않을 것이다. 추가를 눌러 공유폴더를 추가하자.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520638-95df5700-d6ec-11eb-89ab-8ed9d2dd10b0.png\" /></p>\n\n<p>공유폴더를 선택하고 필요한 설정을 체크한다. 필자는 맥 타임머신을 이용하기 위해 타임머신 지원을 체크하였다. 일반적인 NAS용도라면 딱히 건드릴 설정이 없을 것이다.</p>\n\n<p>여기까지 모든 설정을 완료했다면 FTP와 SMB를 사용하여 공유폴더에 접근가능할 것이다.</p>\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\" data-enlighter-theme=\"godzilla\" data-enlighter-linenumbers=\"false\">ftp://***.***.*.*\nsmb://***.***.*.*</pre>  \n\n<p>이런 형식으로 해당 서버에 접근 가능할 것이다.</p>\n\n<p> </p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/raspberrypi/","name":"2021-02-27-madeNAS.md","path":"post/raspberrypi/2021-02-27-madeNAS.md","url":"/post/raspberrypi/2021-02-27-madeNAS.html"},{"sort":3,"title":"트랜스미션 &#8220;Permission denied&#8230;&#8221; 오류 해결하기","date":"2021-03-02 16:00:59 +0900","author":"altair823","categories":["라즈베리파이"],"layout":"default","content":"<p><img src=\"https://user-images.githubusercontent.com/46125008/123520657-9d066500-d6ec-11eb-8a72-3f0d2c95f995.png\" /></p>\n\n<p>정리하자면 “Permission” 오류는 토렌트로 받은 파일을 저장할 공간의 권한 문제로 발생하는 오류라는 것이다. 다운로드 할 목적지 폴더와 트랜스미션의 사용자를 맞춰주면 된다. 모든 권한을 열고 트랜스미션의 유저 이름을 root로 하는 것도 방법이지만 블로그 서버도 돌아가는 라즈베리파이의 보안을 신경쓰지 않을 수 없다. 따라서 폴더의 소유자와 그 권한을 바꾸는 작업을 했다.</p>\n\n<h3 id=\"권한의-이해\">권한의 이해</h3>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520656-9d066500-d6ec-11eb-8274-c0106543e204.png\" /></p>\n\n<p>ssh로 접속하여 ls -al로 확인한 전체 폴더들의 권한들이다. 맨 앞의 d는 디렉터리, 즉 폴더라는 뜻이다. 그 뒤로 나타나는 r, w, x는 각각 read, write, execute, 그러니까 읽기권한, 쓰기권한, 실행권한이라는 뜻이다. d (단일 파일이라면 -)이후의 부분은 세 개씩 잘라 읽으면 되는데, 앞에서부터 [소유자의 권한][그룹의 권한][그 외 사용자의 권한]을 뜻한다.</p>\n\n<p>또한 s와 t는 특수권한을 뜻하는데, 소유자 권한에 붙으면 해당 파일의 접근 권한을 다른 사용자가 잠시 빌려올 수 있도록 허용하는 것이다. 그룹 권한에 붙으면 역시 파일의 접근 권한을 그룹에서 다른 사용자가 잠시 빌려올 수 있다. 이 두 경우 x대신 s가 들어가게 된다. 그 외의 사용자 권한에 특수권한이 붙으면 x대신 t가 붙게 되며 이는 파일의 생성은 누구나 가능하지만 삭제는 생성한 사람과 소유자만 가능하게 하는 옵션이다.</p>\n\n<p>따라서 위에 보이는 문자들을 해석해보면</p>\n\n<p>d rwx rws r-x :</p>\n\n<ol>\n <li>이는 폴더이며,</li>\n <li>소유자(root)에게 모든 권한을 주고 있고,</li>\n <li> 해당 그룹(user)에게 역시 모든 권한을 주고 있으며,</li>\n <li>다른 사용자들은 읽기와 실행만 가능하다.</li>\n <li>하지만 소유 그룹의 파일을 실행해야 할 경우 해당 그룹의 권한을 빌려 다른 사람이 실행할 수 있다.</li>\n</ol>\n\n<h3 id=\"해결\">해결</h3>\n\n<p>권한의 종류들을 알았으니 이제 폴더의 권한을 바꿔줄때다. chmod로 파일의 권한을, chown으로 소유자과 그룹을 바꿀 수 있다. 먼저 트랜스미션을 정지한다.</p>\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\" data-enlighter-theme=\"godzilla\" data-enlighter-linenumbers=\"false\">sudo service transmission-daemon stop</pre>  \n\n<p>트랜스미션의 유저 이름은 debian-transmission이다. 따라서</p>\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\" data-enlighter-theme=\"godzilla\" data-enlighter-linenumbers=\"false\">sudo chown -R Debian-transmission (토렌트 파일을 저장할 폴더명, 또는 경로)/</pre>  \n\n<p>를 입력해 소유자를 바꾸면 된다. 여기서 옵션으로 준 -R은 하위 폴더와 파일들의 권한까지 일괄적으로 변경하는 옵션이다. 만약 이렇게 했는데도 권한오류가 발생한다면</p>\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\" data-enlighter-theme=\"godzilla\" data-enlighter-linenumbers=\"false\">sudo chmod -R 777 (토렌트 파일을 저장할 폴더명, 또는 경로)/</pre>  \n\n<p>를 입력해 권한을 바꿔주면 된다. 이렇게 하면 소유자나 소유 그룹 뿐만 아니라 다른 사용자도 폴더에 접근해 쓰기를 할 수 있다. 이제 트랜스미션을 다시 실행한다.</p>\n\n<pre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\" data-enlighter-theme=\"godzilla\" data-enlighter-linenumbers=\"false\">sudo service transmission-daemon start</pre>  \n\n<p>다시 토렌트 파일들을 넣어 확인해보면 정상적으로 작동하는 것을 볼수 있을 것이다.</p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/raspberrypi/","name":"2021-03-02-transmission_error.md","path":"post/raspberrypi/2021-03-02-transmission_error.md","url":"/post/raspberrypi/2021-03-02-transmission_error.html"},{"sort":3,"permalink":"/post/raspberrypi/","layout":"default","title":"라즈베리파이","content":"<h1 id=\"라즈베리파이\">라즈베리파이</h1>\n\n<ul>\n <li><a href=\"/post/raspberrypi/2021-02-27-first.html\">라즈베리파이에 관한 이야기</a></li>\n <li><a href=\"/post/raspberrypi/2021-02-27-madeNAS.html\">라즈베리파이에 OMV로 NAS만들기</a></li>\n <li><a href=\"/post/raspberrypi/2021-03-02-transmission_error.html\">트랜스미션 “Permission denied…” 오류 해결하기</a></li>\n <li><a href=\"/post/raspberrypi/2021-03-02-OMV(1).html\">OMV를 사용하며 겪었던 시행착오들 (1)</a></li>\n <li><a href=\"/post/raspberrypi/2021-03-02-OMV(2).html\">OMV를 사용하며 겪었던 시행착오들 (2)</a></li>\n</ul>\n","dir":"/post/raspberrypi/","name":"README.md","path":"post/raspberrypi/README.md","url":"/post/raspberrypi/"},{"sort":4,"title":"OMV를 사용하며 겪었던 시행착오들 (1)","date":"2021-03-02 07:33:45 +0900","author":"altair823","categories":["NAS"],"layout":"default","content":"<h2 id=\"1-서론\">1. 서론</h2>\n\n<p>OMV는 분명 강력한 나스 운영체제다. 1기가비트 이상 속도나 무조건적인 안정성이 반드시 필요하지 않다면 라즈베리파이에 설치된 OMV는 정말로 충분하고도 남는 성능을 보여준다. 나는 그동안 나스의 저장장치로 USB스틱, HDD, SSD 모두 사용해 보았다. 저렴한 가격에 USB를 사용해 보았지만 너무나 낮은 쓰기 속도로 인해 하드디스크를 달았고, 컴퓨터를 업그레이드 하면서 나온 SSD를 라즈베리파이에 달았다. 나는 전자제품을 커스터마이징 할 때 기기가 할 수 있는 모든 기능을 다 경험해본 다음 깔끔하게 포맷하여 내가 필요한 기능만을 사용하는 것을 좋아한다. 그래서 라즈베리파이에 달릴 저장장치들을 추가할 때마다 여러번 OMV를 밀고 다시 설치하기를 반복했다.</p>\n\n<p>그러나 그때마다 정말로 다양한 문제를 마주하였다. 그리고 그런 문제의 답은 단순히 프로젝트 소개, how to do 수준의 글들에서는 찾아볼 수 없는 경우가 많았다. 얕은 지식 수준에서 스스로 해결할 수 있는 문제는 별로 없었고, 아주 작은 요류만으로도 라즈비안 전체를 포맷해야 하는 불쾌한 경험을 했다.</p>\n\n<p>그런 과정 속에서 얻은 얼마 안되는 해결책을 좀 써보려고 한다. 많은 것들을 외국 페이지들에서 배웠고 특히 OMV공식 포럼에서 많은 도움을 받았다. 맨 땅에 헤딩하며 배우는 것들도 있겠지만 가장 좋은 것은 헤딩도 하지 않고 배우는 것이라고 생각하며 겪었던 경험들을 소개한다.</p>\n\n<h2 id=\"2-시행착오들\">2. 시행착오들</h2>\n\n<h4 id=\"1-라즈베리파이-sd카드-슬롯고장\">1) 라즈베리파이 SD카드 슬롯고장</h4>\n\n<p>나는 데비안 기반 운영체제를 라즈베리파이로 처음 접했다.  sudo, apt, 그 모든게 너무나 이질적이면서도 신기했다. 프로그램을 설치하려고 온갖 사이트를 돌아다닐 필요없이 영어 몇 줄이면 알아서 필요한 프로그램을 깔아주는 터미널은 정말 충격적이었다. 라즈비안 lite버전을 깔아 GUI환경을 내 맘대로 구성하는 것은 하얀 눈에 그림그리는 어린 아이가 된 기분이었다.</p>\n\n<p>그렇게 신기한 것들을 경험하던 어느 날, 라즈베리파이가 부팅이 되지 않았다. 모니터가 하나 밖에 없었기에 주로 ssh를 통해 제어하던 나는 단지 ssh 연결 문제인줄 알았다. 하지만 모니터에 연결하여 부팅했을 때 나온 메시지는 마이크로 sd카드가 존재하지 않다는 것이었다. 항상 백업은 중요하다고 생각한다. 그래서 처음 주문할 때도 sd카드를 두 개 주문했었다. 하나는 주로 사용할 sd카드, 하나는 백업을 하거나 실험적인 테스트를 할 sd카드였다. 하지만 얼척 없게도 두 카드 모두 인식이 되지 않았다. 두 카드 모두 OMV가 설치된 라즈비안이 깔려있었다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520644-98da4780-d6ec-11eb-9ef5-570e68c41aeb.jpg\" /></p>\n\n<p>마이크로 sd카드는 상대적으로 불안정하고 특히 전원이 순간적으로 차단되면 안에 파일들이 깨질 수 있다는 글을 보았다. 얼핏 기억하기로는 전원이 켜져있었던 상태로 sd카드를 뽑았던 것 같았다. 그렇게 카드 고장인 줄 알고 새 카드를 주문했다. 하지만 새 카드 역시 인식이 되지 않았다. 그제서야 sd카드 리더기로 컴퓨터에 연결해 보았더니 모두 인식이 정상적으로 되는 것이었다. 하나의 남은 가능성은 라즈베리파이의 sd카드 슬롯의 고장이었다.</p>\n\n<p>파이를 어떻게 부팅해야할까 고민하던 찰나, usb에 os를 설치하여 라즈베리파이를 부팅할 수 있다는 말을 들었던 기억이 났다. 천만다행히도 주기적인 업데이트 과정에서 라즈베리파이의 부트로더가 업데이트 되어있었다. 내 라즈베리파이는 그때부터 지금까지 마이크로 sd카드보다 더 안정적이고 유연한 usb를 통해 부팅한다.</p>\n\n<p>만약 지금 다시 라즈베리파이를 산다면 특별한 이유가 아니면 개인적으로는 절대 마이크로sd카드를 사용하지 않을 것 같다.  usb, 특히 3.0규격으로 연결한 장치에 os를 설치하면 더욱 안정적이고 빠른 속도를 경험할 수 있다. 임베디드나 IoT같은 용도로 라즈베리파이를 사용하면 마이크로 sd카드의 작은 크기가 분명히 필요한 요소일 것이다. 하지만 나처럼 프로젝트를 여러개 올리거나, 자주 포맷을 해야할 필요가 있거나, 높은 안정성을 기대해야 할 경우에는 부트로더를 업데이트하여 usb부팅을 사용하는 것이 더 나은 방법이라고 생각한다.</p>\n\n<h4 id=\"2-이미-파일이-존재하는-하드디스크를-omv에-설치하기\">2) 이미 파일이 존재하는 하드디스크를 OMV에 설치하기</h4>\n\n<p>컴퓨터에 새 하드를 장착하면 당연하게도 특정한 형식으로 포맷하는게 좋다. 성능적인 면에서나 안정성의 면에서나 심지어 어떤 하드들은 아예 파일 시스템이 잡히지 않는다. OMV에서도 똑같다. 새로 하드를 설치하면 윈도우의 NTFS나 맥의 APFS이 아닌 EXT4나 BTRFS와 같이 리눅스에서 자주 사용하는 형식으로 하드를 포맷하는 것이 좋다.</p>\n\n<p>처음 설치했던 1테라 짜리 하드가 가득 차고 새로 4테라 짜리 하드를 구매하여 연결했다. EXT4로 포맷했고 벌써 1.3테라는 채웠을 때였다. 내가 가진 하드 도킹스테이션은 2베이이고 하드는 총 3개가 있다. 하나는 주 백업 용도, 하나는 맥의 타임머신 용도, 하나는 파일 아카이브 용도로 사용하려고 했다. 그러나 세 개의 하드를 모두 연결하지 않으면 OMV의 설정이 저장되지 않는 오류가 발생했다. (이에 대한 자세한 내용은 밑에서 더 설명한다)  그때는 이에 대한 해결책을 찾지 못했기에 os를 재설치하는 것이 가장 깔끔한 방법이라고 생각했다. 하지만 문제가 있었다. 나는 이미 총 2테가 가량되는 모든 파일을 하드디스크에 백업해둔 상태였으며, 파일들이 저장된 하드들을 다시 포맷하기에는 그 파일들을 옮겨둘 용량을 가진 저장장치가 없었다. 드롭박스나 원드라이브 같은 클라우드 서비스도 를 알아보았으나 용량이 크지 않거나 파일들을 옮기는 속도가 너무 느렸다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520646-9972de00-d6ec-11eb-88eb-c25fb77c1450.png\" /></p>\n\n<p>한국어 웹사이트에서는 이에 대한 명확한 답을 얻지 못했다. 결국 건너건너 도착한 OMV포럼에서 정확한 답을 얻을 수 있었다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520647-9972de00-d6ec-11eb-9771-f35307ec951b.png\" /></p>\n\n<p>공식 문서에 나열된 지원되는 파일 시스템들은 포맷없이 마운트가 가능하고 사용도 가능하다. (웹 UI에서 btrfs의 스냅샷이나 서브볼륨 같은 기능은 사용 불가능하다. 내부 설정을 건드리면 일부 사용 가능하다고는 한다) (zfs는 해당 플러그인을 설치하면 이용할 수 있다) 따라서 EXT4와 같은 지원되는 파일 시스템을 가진, 지워서는 안되는 파일이 있는 장치는 OMV에 따로 포맷 걱정 없이 연결할 수 있다.</p>\n\n<p>이런 정보를 얻은 덕분에 안심하고 os를 재설치 한 뒤 안전하게 하드를 다시 이용할 수 있었다. 단지 유의해야 할 부분이라면 이용하려는 파일들을 OMV 웹 UI 에서 생성한 공유폴더 아래로 옮겨야 한다는 점이다. 아니면 가장 상위폴더 명과 생성하려는 공유폴더 명을 같게하고 경로를 해당 폴더에 잡아주면 그대로 안에 내용들에 접근 가능하다.</p>\n\n<p> </p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/raspberrypi/","name":"2021-03-02-OMV(1).md","path":"post/raspberrypi/2021-03-02-OMV(1).md","url":"/post/raspberrypi/2021-03-02-OMV(1).html"},{"sort":4,"permalink":"/post/extra/","layout":"default","title":"기타","content":"<h1 id=\"기타\">기타</h1>\n\n<ul>\n <li><a href=\"/post/extra/2021-06-02-Linux_mint_review_1.html\">리눅스 민트 설치 후기 1</a></li>\n <li><a href=\"/post/extra/2021-06-02-Linux_mint_review_2.html\">리눅스 민트 설치 후기 2</a></li>\n</ul>\n","dir":"/post/extra/","name":"README.md","path":"post/extra/README.md","url":"/post/extra/"},{"sort":5,"permalink":"/post/Python/","layout":"default","title":"파이썬","content":"<h1 id=\"파이썬\">파이썬</h1>\n\n<ul>\n <li><a href=\"/post/Python/2021-06-30-Project_Word_Finder_1.html\">Word Finder 개발기 1</a></li>\n <li><a href=\"/post/Python/2021-07-05-Project_Word_Finder_2.html\">Word Finder 개발기 2</a></li>\n <li><a href=\"/post/Python/2021-07-05-Project_Word_Finder_3.html\">Word Finder 개발기 3</a></li>\n</ul>\n","dir":"/post/Python/","name":"README.md","path":"post/Python/README.md","url":"/post/Python/"},{"sort":5,"title":"OMV를 사용하며 겪었던 시행착오들 (2)","date":"2021-03-02 07:45:08 +0900","author":"altair823","categories":["NAS"],"layout":"default","content":"<h4 id=\"3-fail-to-execute-command-export-path--오류\">3) Fail to execute command ‘export path= …’ 오류</h4>\n\n<p>컴퓨터를 업그레이드하며 사용하지 못하는 하드가 두 개가 생겼다. 두 하드를 위해 2베이짜리 하드 도킹 스테이션을 구매했으며 거기에 모두 끼워 만족스럽게 사용하고 있었다. 하지만 1테라의 용량은 많은 파일을 백업하기에는 용량이 부족했고 결국 4테라 하드를 주문하기에 이르렀다.</p>\n\n<p>그 후 또 다른 고민에 빠지게 되는데 바로 설치할 수 있는 하드의 최대 개수는 2개인데 갖고 있는 하드는 총 3개라는 것이다. 용량이 가장 작은 500기가 하드를 놀게하려니 여간 아까운게 아니었다. 결국 제일 중요한 문서를 주기적으로 백업하는 용도로 사용하기로 마음먹게 된다. 필요할 때만, 마치 컴퓨터에 usb를 꽂듯이 하드 도킹스테이션에 바꿔끼면 될 것이라고 생각했다. 하지만 테스트하는 과정에서 다음과 같은 오류가 뿜어져 나왔다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520648-9a0b7480-d6ec-11eb-8265-6d0721dcf763.png\" /></p>\n\n<p>하드를 처음 꽂고 파일 시스템을 인식시키면 OMV는 변경사항을 저장할거냐고 물어온다.  아무 생각없이 평소에 하던대로 적용을 누르면 잠시후 위와 같은 오류를 마주하게 된다. 전체 시스템의 재설치까지 해봤지만 오류를 고칠 수 없었다. 더군다나 웹에도 이에대한 해결방법이 딱히 찾아볼 수 없었다.</p>\n\n<p>이 오류의 발생 이유는 간단하다. 원래 있던 하드가 인식되지 않기 때문이다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520649-9a0b7480-d6ec-11eb-8297-e049b5f454fc.png\" /></p>\n\n<p>altairBackup과 TimeMAChine이라는 하드 두개를 사용하고 있었다. 하지만 TimeMAChine 하드를 제거하고 Lv2backup이라는 하드를 인식시킨 모습이다. 타임머신 하드는 ftp와 smb에서 사용하고 있으니 참조도 하고 있다. 이에 대한 설정파일이 있고 오른쪽에 누락이라고 뜨고 있다. 나는 설정을 모두 마친 상황이라 Lv2backup 하드도 참조에 ‘예’라고 표시되지만 처음 인식시켰다면 ‘아니오’가 떠있을 것이다. 이 상태에서 변경사항을 저장하면 오류가 표시된다.</p>\n\n<p>이 상황에서 우리는 몇 가지 방법을 적용해볼 수 있다.</p>\n\n<h5 id=\"1--제거할-하드디스크의-공유를-모두-비활성화한-뒤-하드디스크를-제거한다\">1 – 제거할 하드디스크의 공유를 모두 비활성화한 뒤 하드디스크를 제거한다.</h5>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520650-9aa40b00-d6ec-11eb-9fc2-44db8deca84c.png\" /></p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520651-9b3ca180-d6ec-11eb-8eb2-b887f3731a8c.png\" /></p>\n\n<p>위와 같이 제거하려는 타임머신 하드의 SMB, FTP 공유를 모두 비활성화 한다. 가능하다면 공유 프로토콜 자체도 잠시 끄는게 좋다. 위와 같이 했다면 하드를 제거하고 새 하드를 꽂는다. 이후 새 하드를 마운트하고 변경사항을 적용해본다.</p>\n\n<h5 id=\"2--변경사항을-적용하지-않고-되돌리기를-선택한다\"> 2 – 변경사항을 적용하지 않고 되돌리기를 선택한다.</h5>\n\n<p>이상하게 들릴지 모르지만 간혹 변경사항을 되돌리기를 선택한 후에 모든 것이 정상적으로 작동하기도 한다. 심지어 이후 파일 시스템에 정상적으로 새 장치가 인식되어 있기도 하다. 전제 시스템이 정상적으로 잘 작동하는지 알아보는 방법은 새 공유폴더를 생성해보는 것이다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520652-9b3ca180-d6ec-11eb-9711-b35bf2bfea50.png\" /></p>\n\n<p>어떠한 상황에서도 위와같은 오류가 나타난다면 아직 오류가 해결되지 않은 것이다.</p>\n\n<h5 id=\"3--라즈베리파이를-재부팅-해본다\">3 – 라즈베리파이를 재부팅 해본다.</h5>\n\n<p>오류를 해결하기 위한 가장 기본적인 방법이지만 가끔 이것만으로 위와 같은 오류가 사라지는 경우가 있다. 실제로 포럼에서 위와 같은 오류를 경험한 사람들도 단지 재부팅 한 번으로 해결했다는 경험담이 있다. 정확히는 모르지만 부팅 과정에서 장치들이 자동으로 마운트 되면서 해결되는 것이 아닌가 추측해본다.</p>\n\n<h5 id=\"4--원하는-하드디스크를-제거하고-해당-설정을-모두-삭제한다\">4 – 원하는 하드디스크를 제거하고 해당 설정을 모두 삭제한다.</h5>\n\n<p>비록 귀찮지만 가장 확실한 방법이다. 나도 이 방법으로 하드를 교체하고 있다.</p>\n\n<p>새로운 하드를 설치하기 위해 제거하고 싶은 하드가 있다고 해보자. 먼저 하드를 안전하게 제거하고 ftp나 smb설정에서 해당 하드에 존재하는 공유폴더를 삭제한다. 모든 공유 프로토콜에서 공유폴더를 제거했다면 이제 공유폴더 탭으로 간다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520653-9bd53800-d6ec-11eb-9eb0-1de59f4717f8.png\" /></p>\n\n<p>사진을 보면 참조라는 부분이 있다 이 부분이 ‘아니오’가 되지 않는다면 공유폴더가 삭제되지 않는다. 하드를 제거한 뒤, 만약 아니오가 떠있고 공유폴더를 삭제할 수 있다면 공유폴더를 삭제한다.</p>\n\n<p><img src=\"https://user-images.githubusercontent.com/46125008/123520654-9bd53800-d6ec-11eb-9f61-b3669fbf8c47.png\" /></p>\n\n<p>이후 파일 시스템 탭에 가면 마운트 부분에 ‘아니오’, 참조 부분에 ‘아니오’가 있을 것이다. 이를 안전하게 삭제한다.</p>\n\n<p>이후 새 하드를 인식시키고 마운트한다. 변경사항을 적용하는 버튼을 누르면 이번에는 아무런 오류없이 변경사항이 적용될 것이다. 이제 공유폴더를 생성하고 파일을 장치에 저장할 수 있을 것이다.</p>\n\n<p> </p>\n\n<script src=\"https://utteranc.es/client.js\" repo=\"altair823/blog_comments\" issue-term=\"pathname\" theme=\"github-light\" crossorigin=\"anonymous\" async=\"\">\n</script>\n\n","dir":"/post/raspberrypi/","name":"2021-03-02-OMV(2).md","path":"post/raspberrypi/2021-03-02-OMV(2).md","url":"/post/raspberrypi/2021-03-02-OMV(2).html"}]